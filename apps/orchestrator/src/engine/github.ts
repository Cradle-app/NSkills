import type { IFs } from 'memfs';
import type { GitHubConfig } from '@dapp-forge/blueprint-schema';
import * as path from 'path';

interface CreateRepoResult {
  url: string;
  cloneUrl: string;
  prUrl?: string;
}

/**
 * GitHub integration for repository creation and code commits
 * Supports both OAuth tokens (per-user) and App tokens
 */
export class GitHubIntegration {
  private baseUrl = 'https://api.github.com';
  private userToken: string | null = null;

  /**
   * Set a user-provided OAuth token (from GitHub OAuth flow)
   */
  setUserToken(token: string): void {
    this.userToken = token;
  }

  /**
   * Get the token to use - prefer user token, fallback to env var
   */
  private getToken(): string {
    // Prefer user's OAuth token (from their session)
    if (this.userToken) {
      return this.userToken;
    }
    // Fallback to environment variable (for server-to-server or testing)
    const token = process.env.GITHUB_TOKEN;
    if (!token) {
      throw new Error('No GitHub token available. Please connect your GitHub account.');
    }
    return token;
  }

  /**
   * Create a new repository and commit generated files
   */
  async createRepository(
    config: GitHubConfig,
    fs: IFs,
    sourcePath: string
  ): Promise<CreateRepoResult> {
    const token = this.getToken();

    // Create repository
    const repo = await this.createRepo(token, config);

    // Commit files
    await this.commitFiles(token, config, fs, sourcePath);

    // Optionally create PR
    let prUrl: string | undefined;
    if (config.createPR) {
      prUrl = await this.createPullRequest(token, config);
    }

    return {
      url: repo.html_url,
      cloneUrl: repo.clone_url,
      prUrl,
    };
  }

  /**
   * Create a new GitHub repository
   */
  private async createRepo(
    token: string,
    config: GitHubConfig
  ): Promise<{ html_url: string; clone_url: string }> {
    const response = await fetch(`${this.baseUrl}/user/repos`, {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${token}`,
        Accept: 'application/vnd.github+json',
        'Content-Type': 'application/json',
        'X-GitHub-Api-Version': '2022-11-28',
      },
      body: JSON.stringify({
        name: config.repoName,
        description: `Generated by Cradle`,
        private: config.visibility === 'public',
        auto_init: true,
      }),
    });

    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      console.error('Repo creation failed:', {
        status: response.status,
        statusText: response.statusText,
        error,
        repoName: config.repoName,
        owner: config.owner,
      });
      throw new Error(`Failed to create repository: ${error.message || error.errors?.[0]?.message || response.statusText}`);
    }

    return response.json();
  }

  /**
   * Commit files to repository using Git Data API
   */
  private async commitFiles(
    token: string,
    config: GitHubConfig,
    fs: IFs,
    sourcePath: string
  ): Promise<void> {
    const owner = config.owner;
    const repo = config.repoName;
    const branch = config.defaultBranch;

    // Get all files
    const files = this.walkDirectory(fs, sourcePath);

    // Create blobs for each file
    const blobs: Array<{ path: string; sha: string }> = [];

    for (const file of files) {
      const content = fs.readFileSync(file);
      const relativePath = path.posix.relative(sourcePath, file);

      const blobResponse = await fetch(
        `${this.baseUrl}/repos/${owner}/${repo}/git/blobs`,
        {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: 'application/vnd.github+json',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            content: Buffer.from(content as Buffer).toString('base64'),
            encoding: 'base64',
          }),
        }
      );

      if (!blobResponse.ok) {
        const errorData = await blobResponse.json().catch(() => ({}));
        console.error('Blob creation failed:', {
          file: relativePath,
          status: blobResponse.status,
          error: errorData,
        });
        throw new Error(`Failed to create blob for ${relativePath}: ${errorData.message || blobResponse.statusText}`);
      }

      const blob = await blobResponse.json();
      blobs.push({ path: relativePath, sha: blob.sha });
    }

    // Create tree
    const treeResponse = await fetch(
      `${this.baseUrl}/repos/${owner}/${repo}/git/trees`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: 'application/vnd.github+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          tree: blobs.map(blob => ({
            path: blob.path,
            mode: '100644',
            type: 'blob',
            sha: blob.sha,
          })),
        }),
      }
    );

    if (!treeResponse.ok) {
      throw new Error('Failed to create tree');
    }

    const tree = await treeResponse.json();

    // Create commit
    const commitResponse = await fetch(
      `${this.baseUrl}/repos/${owner}/${repo}/git/commits`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: 'application/vnd.github+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          message: 'Initial commit from Cradle',
          tree: tree.sha,
        }),
      }
    );

    if (!commitResponse.ok) {
      throw new Error('Failed to create commit');
    }

    const commit = await commitResponse.json();

    // Create/update reference
    const refResponse = await fetch(
      `${this.baseUrl}/repos/${owner}/${repo}/git/refs`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: 'application/vnd.github+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          ref: `refs/heads/${branch}`,
          sha: commit.sha,
        }),
      }
    );

    if (!refResponse.ok) {
      // Try updating existing ref
      await fetch(
        `${this.baseUrl}/repos/${owner}/${repo}/git/refs/heads/${branch}`,
        {
          method: 'PATCH',
          headers: {
            Authorization: `Bearer ${token}`,
            Accept: 'application/vnd.github+json',
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            sha: commit.sha,
            force: true,
          }),
        }
      );
    }
  }

  /**
   * Create a pull request
   */
  private async createPullRequest(
    token: string,
    config: GitHubConfig
  ): Promise<string> {
    const owner = config.owner;
    const repo = config.repoName;

    const response = await fetch(
      `${this.baseUrl}/repos/${owner}/${repo}/pulls`,
      {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: 'application/vnd.github+json',
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          title: config.prTitle || 'Cradle: Generated code',
          body: config.prBody || 'This PR contains code generated by Cradle.',
          head: 'cradle-generated',
          base: config.defaultBranch,
        }),
      }
    );

    if (!response.ok) {
      const error = await response.json();
      throw new Error(`Failed to create PR: ${error.message}`);
    }

    const pr = await response.json();
    return pr.html_url;
  }

  /**
   * Walk directory recursively
   */
  private walkDirectory(fs: IFs, dir: string): string[] {
    const results: string[] = [];

    try {
      const items = fs.readdirSync(dir) as string[];

      for (const item of items) {
        const fullPath = path.posix.join(dir, item);
        const stat = fs.statSync(fullPath);

        if (stat.isDirectory()) {
          results.push(...this.walkDirectory(fs, fullPath));
        } else {
          results.push(fullPath);
        }
      }
    } catch {
      // Directory might not exist
    }

    return results;
  }
}

