/**
 * Universal Path Resolver for Cradle Code Generation
 * 
 * Routes plugin outputs to proper category folders (frontend, backend, contracts)
 * based on the context of which plugins are present in the workflow.
 */

import type { BlueprintNode } from '@dapp-forge/blueprint-schema';

/**
 * Path categories for organizing generated files
 * 
 * Each file generated by a plugin should be tagged with one of these categories
 * to enable intelligent routing to the correct output location.
 */
export type PathCategory =
    // Frontend categories
    | 'frontend-app'        // app/, pages/ - main application pages
    | 'frontend-components' // components/ - React components
    | 'frontend-hooks'      // hooks/ - React hooks
    | 'frontend-lib'        // lib/, config/ - utilities, configuration
    | 'frontend-types'      // types/ - TypeScript type definitions
    | 'frontend-styles'     // styles/ - CSS, Tailwind, etc.
    | 'frontend-public'     // public/ - static assets

    // Backend categories
    | 'backend-routes'      // routes/, api/ - API route handlers
    | 'backend-services'    // services/ - business logic services
    | 'backend-middleware'  // middleware/ - Express/Fastify middleware
    | 'backend-lib'         // lib/, utils/ - backend utilities
    | 'backend-types'       // types/ - backend type definitions

    // Contract categories
    | 'contract'            // contracts/<name>/ - smart contract code
    | 'contract-test'       // contracts/<name>/tests/ - contract tests
    | 'contract-source'     // contracts/<name>/ - Stylus/Rust source files

    // Shared/Root categories
    | 'docs'                // docs/ - documentation
    | 'root'                // root level - package.json, turbo.json, etc.
    | 'shared-types'        // shared/ - types shared across frontend/backend
    ;

/**
 * Context built from analyzing blueprint nodes
 * Determines the base paths for each category
 */
export interface PathContext {
    /** Whether a frontend scaffold plugin is present */
    hasFrontend: boolean;

    /** Whether a backend scaffold plugin is present */
    hasBackend: boolean;

    /** Whether any contract plugins are present */
    hasContracts: boolean;

    /** Set of all node types in the blueprint (for plugin detection) */
    nodeTypes: Set<string>;

    /** Base path for frontend files (default: 'apps/web') */
    frontendPath: string;

    /** Source directory within frontend (default: 'src') */
    frontendSrcPath: string;

    /** Base path for backend files (default: 'apps/api') */
    backendPath: string;

    /** Source directory within backend (default: 'src') */
    backendSrcPath: string;

    /** Base path for contracts (default: 'contracts') */
    contractsPath: string;
}

/**
 * Plugin types that indicate a primary scaffold
 */
const FRONTEND_SCAFFOLD_TYPES = ['frontend-scaffold'];
const BACKEND_SCAFFOLD_TYPES: string[] = []; // Future: 'backend-scaffold'
const CONTRACT_TYPES = [
    'stylus-contract',
    'stylus-zk-contract',
    'erc20-stylus',
    'erc721-stylus',
    'erc1155-stylus',
];

/**
 * Build path context from blueprint nodes
 * 
 * Analyzes the nodes in a workflow to determine:
 * - Which scaffolds are present
 * - What base paths to use
 */
export function buildPathContext(nodes: BlueprintNode[]): PathContext {
    const nodeTypesArray = nodes.map(n => n.type);
    const nodeTypes = new Set(nodeTypesArray);

    // Detect scaffolds
    const hasFrontend = nodeTypesArray.some(t => FRONTEND_SCAFFOLD_TYPES.includes(t));
    const hasBackend = nodeTypesArray.some(t => BACKEND_SCAFFOLD_TYPES.includes(t));
    const hasContracts = nodeTypesArray.some(t => CONTRACT_TYPES.includes(t));

    // Get frontend config to determine structure
    const frontendNode = nodes.find(n => n.type === 'frontend-scaffold');
    const frontendConfig = frontendNode?.config as Record<string, unknown> | undefined;

    // Determine paths based on configuration
    const useSrcDirectory = frontendConfig?.srcDirectory !== false;

    return {
        hasFrontend,
        hasBackend,
        hasContracts,
        nodeTypes,
        frontendPath: 'apps/web',
        frontendSrcPath: useSrcDirectory ? 'src' : '',
        backendPath: 'apps/api',
        backendSrcPath: 'src',
        contractsPath: 'contracts',
    };
}

/**
 * Category to subdirectory mapping
 */
const CATEGORY_SUBDIRS: Record<PathCategory, string> = {
    // Frontend
    'frontend-app': 'app',
    'frontend-components': 'components',
    'frontend-hooks': 'hooks',
    'frontend-lib': 'lib',
    'frontend-types': 'types',
    'frontend-styles': 'styles',
    'frontend-public': 'public',

    // Backend
    'backend-routes': 'routes',
    'backend-services': 'services',
    'backend-middleware': 'middleware',
    'backend-lib': 'lib',
    'backend-types': 'types',

    // Contracts
    'contract': '',
    'contract-test': 'tests',
    'contract-source': '',

    // Shared
    'docs': '',
    'root': '',
    'shared-types': 'shared/types',
};

/**
 * Resolve the output path for a file based on its category and context
 * 
 * @param originalPath - The path specified by the plugin
 * @param category - The category of the file (optional)
 * @param context - The path context built from the blueprint
 * @returns The resolved output path
 * 
 * @example
 * // Without frontend scaffold: plugin outputs to 'src/hooks/useMeow.ts'
 * // Result: 'src/hooks/useMeow.ts' (unchanged)
 * 
 * @example
 * // With frontend scaffold: plugin outputs 'useMeow.ts' with category 'frontend-hooks'
 * // Result: 'apps/web/src/hooks/useMeow.ts'
 */
export function resolveOutputPath(
    originalPath: string,
    category: PathCategory | undefined,
    context: PathContext
): string {
    // If no category specified, return original path (backward compatibility)
    if (!category) {
        return originalPath;
    }

    // Determine the base path based on category type
    const isFrontendCategory = category.startsWith('frontend-');
    const isBackendCategory = category.startsWith('backend-');
    const isContractCategory = category.startsWith('contract');

    let basePath = '';

    if (isFrontendCategory && context.hasFrontend) {
        // Route to frontend app
        const srcPath = context.frontendSrcPath ? `/${context.frontendSrcPath}` : '';
        const subdir = CATEGORY_SUBDIRS[category];

        if (category === 'frontend-public') {
            // Public files go in public/ not src/
            basePath = `${context.frontendPath}/public`;
        } else if (category === 'frontend-app') {
            // App files need special handling for Next.js
            basePath = `${context.frontendPath}${srcPath}/app`;
        } else {
            basePath = `${context.frontendPath}${srcPath}/${subdir}`;
        }
    } else if (isBackendCategory && context.hasBackend) {
        // Route to backend app
        const subdir = CATEGORY_SUBDIRS[category];
        basePath = `${context.backendPath}/${context.backendSrcPath}/${subdir}`;
    } else if (isBackendCategory && context.hasFrontend) {
        // Fallback: No backend scaffold but has frontend - route to Next.js API routes
        if (category === 'backend-routes') {
            basePath = `${context.frontendPath}/${context.frontendSrcPath}/app/api`;
        } else {
            // backend-lib, backend-services, etc go to frontend lib
            basePath = `${context.frontendPath}/${context.frontendSrcPath}/lib`;
        }
    } else if (isContractCategory) {
        // Contracts stay in contracts/
        basePath = context.contractsPath;
    } else if (category === 'docs') {
        basePath = 'docs';
    } else if (category === 'root') {
        basePath = '';
    } else if (category === 'shared-types') {
        basePath = 'shared/types';
    } else {
        // Fallback for frontend categories when no frontend scaffold
        // Route to src/ at root level
        if (isFrontendCategory) {
            const subdir = CATEGORY_SUBDIRS[category];
            basePath = `src/${subdir}`;
        } else if (isBackendCategory) {
            // No frontend or backend - still put in src/lib not root
            basePath = 'src/lib';
        } else {
            return originalPath;
        }
    }

    // Extract just the filename from the original path
    const filename = getFilename(originalPath);

    // Combine base path with filename
    return basePath ? `${basePath}/${filename}` : filename;
}

/**
 * Extract filename from a path
 * Handles both unix and windows style paths
 */
function getFilename(path: string): string {
    const parts = path.replace(/\\/g, '/').split('/');
    return parts[parts.length - 1];
}

/**
 * Rewrite all file paths in a CodegenOutput based on context
 * 
 * This is the main entry point used by the execution engine
 */
export function rewriteOutputPaths<T extends { path: string; category?: PathCategory }>(
    files: T[],
    context: PathContext
): T[] {
    return files.map(file => ({
        ...file,
        path: resolveOutputPath(file.path, file.category, context),
    }));
}

/**
 * Helper to create a categorized file path
 * For use in plugins to specify category along with filename
 */
export function categorizedPath(
    filename: string,
    category: PathCategory
): { path: string; category: PathCategory } {
    return { path: filename, category };
}
