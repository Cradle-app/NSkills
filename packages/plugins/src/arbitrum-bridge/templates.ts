import type { z } from 'zod';
import type { ArbitrumBridgeConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof ArbitrumBridgeConfig>;

/**
 * Generate bridge utilities
 */
export function generateBridgeUtils(config: Config): string {
  return dedent(`
    // Arbitrum Bridge Utilities
    // Generated by [N]skills
    
    import { ethers } from 'ethers';
    import {
      EthBridger,
      ${config.enableERC20 ? 'Erc20Bridger,' : ''}
      getArbitrumNetwork,
      ${config.enableMessaging ? 'L1ToL2MessageStatus,' : ''}
    } from '@arbitrum/sdk';
    import { parseEther, formatEther, type Address } from 'viem';
    
    // Network configuration
    export const NETWORKS = {
      arbitrum: {
        l1ChainId: 1,
        l2ChainId: 42161,
        name: 'Arbitrum One',
      },
      arbitrumSepolia: {
        l1ChainId: 11155111,
        l2ChainId: 421614,
        name: 'Arbitrum Sepolia',
      },
    } as const;
    
    export type NetworkName = keyof typeof NETWORKS;
    
    /**
     * Get providers for L1 and L2
     */
    export function getProviders(network: NetworkName = '${config.targetNetwork}') {
      const l1RpcUrl = process.env.NEXT_PUBLIC_L1_RPC_URL;
      const l2RpcUrl = process.env.NEXT_PUBLIC_L2_RPC_URL;
      
      if (!l1RpcUrl || !l2RpcUrl) {
        throw new Error('Missing RPC URLs. Set NEXT_PUBLIC_L1_RPC_URL and NEXT_PUBLIC_L2_RPC_URL');
      }
      
      return {
        l1Provider: new ethers.JsonRpcProvider(l1RpcUrl),
        l2Provider: new ethers.JsonRpcProvider(l2RpcUrl),
        network: NETWORKS[network],
      };
    }
    
    /**
     * Create an ETH bridger instance
     */
    export async function createEthBridger(network: NetworkName = '${config.targetNetwork}') {
      const { l2Provider } = getProviders(network);
      const arbitrumNetwork = await getArbitrumNetwork(l2Provider);
      return new EthBridger(arbitrumNetwork);
    }
    
    ${config.enableERC20 ? `
    /**
     * Create an ERC-20 bridger instance
     */
    export async function createErc20Bridger(network: NetworkName = '${config.targetNetwork}') {
      const { l2Provider } = getProviders(network);
      const arbitrumNetwork = await getArbitrumNetwork(l2Provider);
      return new Erc20Bridger(arbitrumNetwork);
    }
    ` : ''}
    
    /**
     * Deposit ETH from L1 to L2
     */
    export async function depositEth(
      signer: ethers.Signer,
      amount: string,
      network: NetworkName = '${config.targetNetwork}'
    ) {
      const ethBridger = await createEthBridger(network);
      const { l2Provider } = getProviders(network);
      
      const depositTx = await ethBridger.deposit({
        amount: parseEther(amount),
        l1Signer: signer,
        l2Provider,
      });
      
      const receipt = await depositTx.wait();
      
      return {
        l1TxHash: receipt.transactionHash,
        amount,
      };
    }
    
    /**
     * Withdraw ETH from L2 to L1
     */
    export async function withdrawEth(
      signer: ethers.Signer,
      amount: string,
      destinationAddress?: string,
      network: NetworkName = '${config.targetNetwork}'
    ) {
      const ethBridger = await createEthBridger(network);
      
      const withdrawTx = await ethBridger.withdraw({
        amount: parseEther(amount),
        l2Signer: signer,
        destinationAddress: destinationAddress ?? await signer.getAddress(),
        from: await signer.getAddress(),
      });
      
      const receipt = await withdrawTx.wait();
      
      return {
        l2TxHash: receipt.transactionHash,
        amount,
      };
    }
    
    ${config.enableERC20 ? `
    /**
     * Get L2 token address for an L1 token
     */
    export async function getL2TokenAddress(
      l1TokenAddress: Address,
      network: NetworkName = '${config.targetNetwork}'
    ): Promise<Address | null> {
      const erc20Bridger = await createErc20Bridger(network);
      const { l2Provider } = getProviders(network);
      
      try {
        const l2Address = await erc20Bridger.getL2ERC20Address({
          erc20L1Address: l1TokenAddress,
          l2Provider,
        });
        return l2Address as Address;
      } catch {
        return null;
      }
    }
    
    /**
     * Approve token for bridging
     */
    export async function approveTokenForBridge(
      signer: ethers.Signer,
      tokenAddress: Address,
      amount: bigint,
      network: NetworkName = '${config.targetNetwork}'
    ) {
      const erc20Bridger = await createErc20Bridger(network);
      
      const approveTx = await erc20Bridger.approveToken({
        l1Signer: signer,
        erc20L1Address: tokenAddress,
      });
      
      return approveTx.wait();
    }
    
    /**
     * Deposit ERC-20 from L1 to L2
     */
    export async function depositToken(
      signer: ethers.Signer,
      tokenAddress: Address,
      amount: bigint,
      network: NetworkName = '${config.targetNetwork}'
    ) {
      const erc20Bridger = await createErc20Bridger(network);
      const { l1Provider, l2Provider } = getProviders(network);
      
      const depositTx = await erc20Bridger.deposit({
        l1Signer: signer,
        l2Provider,
        erc20L1Address: tokenAddress,
        amount,
      });
      
      const receipt = await depositTx.wait();
      
      return {
        l1TxHash: receipt.transactionHash,
        tokenAddress,
        amount: amount.toString(),
      };
    }
    
    /**
     * Withdraw ERC-20 from L2 to L1
     */
    export async function withdrawToken(
      signer: ethers.Signer,
      tokenAddress: Address,
      amount: bigint,
      destinationAddress?: string,
      network: NetworkName = '${config.targetNetwork}'
    ) {
      const erc20Bridger = await createErc20Bridger(network);
      
      const withdrawTx = await erc20Bridger.withdraw({
        l2Signer: signer,
        erc20l1Address: tokenAddress,
        amount,
        destinationAddress: destinationAddress ?? await signer.getAddress(),
      });
      
      const receipt = await withdrawTx.wait();
      
      return {
        l2TxHash: receipt.transactionHash,
        tokenAddress,
        amount: amount.toString(),
      };
    }
    ` : ''}
    
    /**
     * Estimate gas for ETH deposit
     */
    export async function estimateEthDepositGas(
      amount: string,
      network: NetworkName = '${config.targetNetwork}'
    ) {
      const ethBridger = await createEthBridger(network);
      const { l1Provider, l2Provider } = getProviders(network);
      
      // Get a dummy address for estimation
      const dummyAddress = '0x0000000000000000000000000000000000000001';
      
      const gasEstimate = await ethBridger.getDepositRequestOutboundTransferGasEstimate({
        l1Provider,
        l2Provider,
        amount: parseEther(amount),
        from: dummyAddress,
      });
      
      return gasEstimate;
    }
  `);
}

/**
 * Generate retryable ticket helpers
 */
export function generateRetryableHelpers(config: Config): string {
  return dedent(`
    // Retryable Ticket Helpers
    // Generated by [N]skills
    
    import { ethers } from 'ethers';
    import {
      L1ToL2MessageStatus,
      L1TransactionReceipt,
      L2ToL1MessageStatus,
      L2TransactionReceipt,
    } from '@arbitrum/sdk';
    import { getProviders, type NetworkName } from './bridge-utils';
    
    export type DepositStatus = 'PENDING' | 'REDEEMED' | 'EXPIRED' | 'NOT_FOUND';
    export type WithdrawalStatus = 'UNCONFIRMED' | 'CONFIRMED' | 'EXECUTED' | 'NOT_FOUND';
    
    /**
     * Get the status of an L1 to L2 deposit
     */
    export async function getDepositStatus(
      l1TxHash: string,
      network: NetworkName = '${config.targetNetwork}'
    ): Promise<{
      status: DepositStatus;
      l2TxHash?: string;
      retryableTicketId?: string;
    }> {
      const { l1Provider, l2Provider } = getProviders(network);
      
      try {
        const l1TxReceipt = await l1Provider.getTransactionReceipt(l1TxHash);
        if (!l1TxReceipt) {
          return { status: 'NOT_FOUND' };
        }
        
        const l1Receipt = new L1TransactionReceipt(l1TxReceipt);
        const messages = await l1Receipt.getL1ToL2Messages(l2Provider);
        
        if (messages.length === 0) {
          return { status: 'PENDING' };
        }
        
        const message = messages[0];
        const status = await message.status();
        
        if (status === L1ToL2MessageStatus.REDEEMED) {
          const redemptionTx = await message.getSuccessfulRedeem();
          return {
            status: 'REDEEMED',
            l2TxHash: redemptionTx?.l2TxReceipt?.transactionHash,
            retryableTicketId: message.retryableCreationId,
          };
        }
        
        if (status === L1ToL2MessageStatus.EXPIRED) {
          return { status: 'EXPIRED', retryableTicketId: message.retryableCreationId };
        }
        
        return { status: 'PENDING', retryableTicketId: message.retryableCreationId };
      } catch (error) {
        console.error('Error getting deposit status:', error);
        return { status: 'NOT_FOUND' };
      }
    }
    
    /**
     * Get the status of an L2 to L1 withdrawal
     */
    export async function getWithdrawalStatus(
      l2TxHash: string,
      network: NetworkName = '${config.targetNetwork}'
    ): Promise<{
      status: WithdrawalStatus;
      canExecute: boolean;
      confirmationBlockNumber?: number;
    }> {
      const { l1Provider, l2Provider } = getProviders(network);
      
      try {
        const l2TxReceipt = await l2Provider.getTransactionReceipt(l2TxHash);
        if (!l2TxReceipt) {
          return { status: 'NOT_FOUND', canExecute: false };
        }
        
        const l2Receipt = new L2TransactionReceipt(l2TxReceipt);
        const messages = await l2Receipt.getL2ToL1Messages(l1Provider);
        
        if (messages.length === 0) {
          return { status: 'NOT_FOUND', canExecute: false };
        }
        
        const message = messages[0];
        const status = await message.status(l2Provider);
        
        if (status === L2ToL1MessageStatus.EXECUTED) {
          return { status: 'EXECUTED', canExecute: false };
        }
        
        if (status === L2ToL1MessageStatus.CONFIRMED) {
          return { status: 'CONFIRMED', canExecute: true };
        }
        
        return { status: 'UNCONFIRMED', canExecute: false };
      } catch (error) {
        console.error('Error getting withdrawal status:', error);
        return { status: 'NOT_FOUND', canExecute: false };
      }
    }
    
    /**
     * Manually redeem a failed retryable ticket
     */
    export async function redeemRetryableTicket(
      signer: ethers.Signer,
      l1TxHash: string,
      network: NetworkName = '${config.targetNetwork}'
    ) {
      const { l1Provider, l2Provider } = getProviders(network);
      
      const l1TxReceipt = await l1Provider.getTransactionReceipt(l1TxHash);
      if (!l1TxReceipt) {
        throw new Error('L1 transaction not found');
      }
      
      const l1Receipt = new L1TransactionReceipt(l1TxReceipt);
      const messages = await l1Receipt.getL1ToL2Messages(l2Provider);
      
      if (messages.length === 0) {
        throw new Error('No retryable messages found');
      }
      
      const message = messages[0];
      const status = await message.status();
      
      if (status === L1ToL2MessageStatus.REDEEMED) {
        throw new Error('Message already redeemed');
      }
      
      if (status === L1ToL2MessageStatus.EXPIRED) {
        throw new Error('Message has expired');
      }
      
      // Need an L2 signer for redemption
      const l2Signer = signer.connect(l2Provider) as ethers.Signer;
      
      const redeemTx = await message.redeem({ l2Signer });
      return redeemTx.wait();
    }
    
    /**
     * Execute a confirmed L2 to L1 withdrawal
     */
    export async function executeWithdrawal(
      signer: ethers.Signer,
      l2TxHash: string,
      network: NetworkName = '${config.targetNetwork}'
    ) {
      const { l1Provider, l2Provider } = getProviders(network);
      
      const l2TxReceipt = await l2Provider.getTransactionReceipt(l2TxHash);
      if (!l2TxReceipt) {
        throw new Error('L2 transaction not found');
      }
      
      const l2Receipt = new L2TransactionReceipt(l2TxReceipt);
      const messages = await l2Receipt.getL2ToL1Messages(l1Provider);
      
      if (messages.length === 0) {
        throw new Error('No withdrawal messages found');
      }
      
      const message = messages[0];
      const status = await message.status(l2Provider);
      
      if (status === L2ToL1MessageStatus.EXECUTED) {
        throw new Error('Withdrawal already executed');
      }
      
      if (status !== L2ToL1MessageStatus.CONFIRMED) {
        throw new Error('Withdrawal not yet confirmed. Please wait for the challenge period.');
      }
      
      const executeTx = await message.execute(l2Provider);
      return executeTx.wait();
    }
  `);
}

/**
 * Generate React hooks for bridge functionality
 */
export function generateBridgeHooks(config: Config): string {
  return dedent(`
    // Bridge Hooks
    // Generated by [N]skills
    
    'use client';
    
    import { useState, useCallback } from 'react';
    import { useAccount, useWalletClient } from 'wagmi';
    import { ethers } from 'ethers';
    import {
      depositEth,
      withdrawEth,
      ${config.enableERC20 ? 'depositToken, withdrawToken, approveTokenForBridge, getL2TokenAddress,' : ''}
      type NetworkName,
    } from '@/lib/bridge/bridge-utils';
    import {
      getDepositStatus,
      getWithdrawalStatus,
      redeemRetryableTicket,
      executeWithdrawal,
      type DepositStatus,
      type WithdrawalStatus,
    } from '@/lib/bridge/retryable-helpers';
    import type { Address } from 'viem';
    
    export interface UseBridgeReturn {
      // State
      isLoading: boolean;
      error: Error | null;
      
      // ETH operations
      depositEth: (params: { amount: string }) => Promise<{ l1TxHash: string }>;
      withdrawEth: (params: { amount: string; destination?: string }) => Promise<{ l2TxHash: string }>;
      
      ${config.enableERC20 ? `
      // Token operations
      approveToken: (params: { tokenAddress: Address; amount: bigint }) => Promise<void>;
      depositToken: (params: { tokenAddress: Address; amount: bigint }) => Promise<{ l1TxHash: string }>;
      withdrawToken: (params: { tokenAddress: Address; amount: bigint; destination?: string }) => Promise<{ l2TxHash: string }>;
      getL2Token: (l1Address: Address) => Promise<Address | null>;
      ` : ''}
      
      // Status checks
      checkDepositStatus: (l1TxHash: string) => Promise<{ status: DepositStatus; l2TxHash?: string }>;
      checkWithdrawalStatus: (l2TxHash: string) => Promise<{ status: WithdrawalStatus; canExecute: boolean }>;
      
      // Recovery
      redeemTicket: (l1TxHash: string) => Promise<void>;
      executeWithdrawal: (l2TxHash: string) => Promise<void>;
    }
    
    /**
     * Hook for Arbitrum bridge operations
     */
    export function useBridge(network: NetworkName = '${config.targetNetwork}'): UseBridgeReturn {
      const { address } = useAccount();
      const { data: walletClient } = useWalletClient();
      
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<Error | null>(null);
      
      // Convert wagmi wallet client to ethers signer
      const getSigner = useCallback(async () => {
        if (!walletClient) {
          throw new Error('Wallet not connected');
        }
        
        // Create an ethers provider from the wallet client
        const provider = new ethers.BrowserProvider(walletClient.transport);
        return provider.getSigner();
      }, [walletClient]);
      
      // Deposit ETH
      const handleDepositEth = useCallback(async ({ amount }: { amount: string }) => {
        setIsLoading(true);
        setError(null);
        
        try {
          const signer = await getSigner();
          const result = await depositEth(signer, amount, network);
          return { l1TxHash: result.l1TxHash };
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Deposit failed');
          setError(error);
          throw error;
        } finally {
          setIsLoading(false);
        }
      }, [getSigner, network]);
      
      // Withdraw ETH
      const handleWithdrawEth = useCallback(async ({ 
        amount, 
        destination 
      }: { 
        amount: string; 
        destination?: string 
      }) => {
        setIsLoading(true);
        setError(null);
        
        try {
          const signer = await getSigner();
          const result = await withdrawEth(signer, amount, destination, network);
          return { l2TxHash: result.l2TxHash };
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Withdrawal failed');
          setError(error);
          throw error;
        } finally {
          setIsLoading(false);
        }
      }, [getSigner, network]);
      
      ${config.enableERC20 ? `
      // Approve token
      const handleApproveToken = useCallback(async ({ 
        tokenAddress, 
        amount 
      }: { 
        tokenAddress: Address; 
        amount: bigint 
      }) => {
        setIsLoading(true);
        setError(null);
        
        try {
          const signer = await getSigner();
          await approveTokenForBridge(signer, tokenAddress, amount, network);
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Approval failed');
          setError(error);
          throw error;
        } finally {
          setIsLoading(false);
        }
      }, [getSigner, network]);
      
      // Deposit token
      const handleDepositToken = useCallback(async ({ 
        tokenAddress, 
        amount 
      }: { 
        tokenAddress: Address; 
        amount: bigint 
      }) => {
        setIsLoading(true);
        setError(null);
        
        try {
          const signer = await getSigner();
          const result = await depositToken(signer, tokenAddress, amount, network);
          return { l1TxHash: result.l1TxHash };
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Token deposit failed');
          setError(error);
          throw error;
        } finally {
          setIsLoading(false);
        }
      }, [getSigner, network]);
      
      // Withdraw token
      const handleWithdrawToken = useCallback(async ({ 
        tokenAddress, 
        amount, 
        destination 
      }: { 
        tokenAddress: Address; 
        amount: bigint; 
        destination?: string 
      }) => {
        setIsLoading(true);
        setError(null);
        
        try {
          const signer = await getSigner();
          const result = await withdrawToken(signer, tokenAddress, amount, destination, network);
          return { l2TxHash: result.l2TxHash };
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Token withdrawal failed');
          setError(error);
          throw error;
        } finally {
          setIsLoading(false);
        }
      }, [getSigner, network]);
      
      // Get L2 token address
      const handleGetL2Token = useCallback(async (l1Address: Address) => {
        return getL2TokenAddress(l1Address, network);
      }, [network]);
      ` : ''}
      
      // Check deposit status
      const handleCheckDepositStatus = useCallback(async (l1TxHash: string) => {
        return getDepositStatus(l1TxHash, network);
      }, [network]);
      
      // Check withdrawal status
      const handleCheckWithdrawalStatus = useCallback(async (l2TxHash: string) => {
        return getWithdrawalStatus(l2TxHash, network);
      }, [network]);
      
      // Redeem retryable ticket
      const handleRedeemTicket = useCallback(async (l1TxHash: string) => {
        setIsLoading(true);
        setError(null);
        
        try {
          const signer = await getSigner();
          await redeemRetryableTicket(signer, l1TxHash, network);
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Redemption failed');
          setError(error);
          throw error;
        } finally {
          setIsLoading(false);
        }
      }, [getSigner, network]);
      
      // Execute withdrawal
      const handleExecuteWithdrawal = useCallback(async (l2TxHash: string) => {
        setIsLoading(true);
        setError(null);
        
        try {
          const signer = await getSigner();
          await executeWithdrawal(signer, l2TxHash, network);
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Execution failed');
          setError(error);
          throw error;
        } finally {
          setIsLoading(false);
        }
      }, [getSigner, network]);
      
      return {
        isLoading,
        error,
        depositEth: handleDepositEth,
        withdrawEth: handleWithdrawEth,
        ${config.enableERC20 ? `
        approveToken: handleApproveToken,
        depositToken: handleDepositToken,
        withdrawToken: handleWithdrawToken,
        getL2Token: handleGetL2Token,
        ` : ''}
        checkDepositStatus: handleCheckDepositStatus,
        checkWithdrawalStatus: handleCheckWithdrawalStatus,
        redeemTicket: handleRedeemTicket,
        executeWithdrawal: handleExecuteWithdrawal,
      };
    }
  `);
}

/**
 * Generate bridge UI component
 */
export function generateBridgeUI(config: Config): string {
  return dedent(`
    // Bridge Widget Component
    // Generated by [N]skills
    
    'use client';
    
    import { useState } from 'react';
    import { useAccount, useBalance } from 'wagmi';
    import { parseEther, formatEther } from 'viem';
    import { useBridge } from '@/hooks/useBridge';
    
    type Direction = 'deposit' | 'withdraw';
    
    interface BridgeWidgetProps {
      className?: string;
    }
    
    export function BridgeWidget({ className }: BridgeWidgetProps) {
      const { address, isConnected } = useAccount();
      const { data: balance } = useBalance({ address });
      const { depositEth, withdrawEth, isLoading, error } = useBridge();
      
      const [direction, setDirection] = useState<Direction>('deposit');
      const [amount, setAmount] = useState('');
      const [txHash, setTxHash] = useState<string | null>(null);
      
      const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault();
        
        if (!amount) return;
        
        try {
          if (direction === 'deposit') {
            const result = await depositEth({ amount });
            setTxHash(result.l1TxHash);
          } else {
            const result = await withdrawEth({ amount });
            setTxHash(result.l2TxHash);
          }
          setAmount('');
        } catch (err) {
          console.error('Bridge error:', err);
        }
      };
      
      if (!isConnected) {
        return (
          <div className={className}>
            <div className="p-6 bg-zinc-900 rounded-lg border border-zinc-800">
              <p className="text-zinc-400 text-center">Connect wallet to use the bridge</p>
            </div>
          </div>
        );
      }
      
      return (
        <div className={className}>
          <div className="p-6 bg-zinc-900 rounded-lg border border-zinc-800 space-y-4">
            <h2 className="text-xl font-semibold text-white">Arbitrum Bridge</h2>
            
            {/* Direction Toggle */}
            <div className="flex gap-2">
              <button
                onClick={() => setDirection('deposit')}
                className={\`flex-1 py-2 px-4 rounded-lg font-medium transition-colors \${
                  direction === 'deposit'
                    ? 'bg-emerald-600 text-white'
                    : 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                }\`}
              >
                Deposit (L1 → L2)
              </button>
              <button
                onClick={() => setDirection('withdraw')}
                className={\`flex-1 py-2 px-4 rounded-lg font-medium transition-colors \${
                  direction === 'withdraw'
                    ? 'bg-emerald-600 text-white'
                    : 'bg-zinc-800 text-zinc-400 hover:bg-zinc-700'
                }\`}
              >
                Withdraw (L2 → L1)
              </button>
            </div>
            
            {/* Amount Input */}
            <form onSubmit={handleSubmit} className="space-y-4">
              <div>
                <label className="block text-sm text-zinc-400 mb-2">Amount (ETH)</label>
                <div className="relative">
                  <input
                    type="number"
                    step="0.0001"
                    min="0"
                    value={amount}
                    onChange={(e) => setAmount(e.target.value)}
                    placeholder="0.0"
                    className="w-full px-4 py-3 bg-zinc-800 border border-zinc-700 rounded-lg 
                             text-white placeholder-zinc-500 focus:outline-none focus:border-emerald-500"
                  />
                  <button
                    type="button"
                    onClick={() => setAmount(formatEther(balance?.value ?? 0n))}
                    className="absolute right-3 top-1/2 -translate-y-1/2 text-xs text-emerald-500 
                             hover:text-emerald-400"
                  >
                    MAX
                  </button>
                </div>
                {balance && (
                  <p className="text-xs text-zinc-500 mt-1">
                    Balance: {formatEther(balance.value)} ETH
                  </p>
                )}
              </div>
              
              {/* Warning for withdrawals */}
              {direction === 'withdraw' && (
                <div className="p-3 bg-amber-900/20 border border-amber-800 rounded-md">
                  <p className="text-sm text-amber-400">
                    ⚠️ Withdrawals have a ~7 day challenge period on mainnet
                  </p>
                </div>
              )}
              
              {/* Error */}
              {error && (
                <div className="p-3 bg-red-900/20 border border-red-800 rounded-md">
                  <p className="text-sm text-red-400">{error.message}</p>
                </div>
              )}
              
              {/* Success */}
              {txHash && (
                <div className="p-3 bg-emerald-900/20 border border-emerald-800 rounded-md">
                  <p className="text-sm text-emerald-400">
                    Transaction submitted!
                  </p>
                  <a
                    href={\`https://\${direction === 'deposit' ? 'etherscan.io' : 'arbiscan.io'}/tx/\${txHash}\`}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="text-xs text-emerald-500 hover:underline font-mono"
                  >
                    {txHash.slice(0, 10)}...{txHash.slice(-8)}
                  </a>
                </div>
              )}
              
              {/* Submit Button */}
              <button
                type="submit"
                disabled={isLoading || !amount}
                className="w-full py-3 bg-emerald-600 hover:bg-emerald-700 disabled:bg-zinc-700 
                         text-white rounded-lg font-medium transition-colors"
              >
                {isLoading
                  ? 'Processing...'
                  : direction === 'deposit'
                  ? 'Deposit to Arbitrum'
                  : 'Withdraw to Ethereum'}
              </button>
            </form>
          </div>
        </div>
      );
    }
    
    export default BridgeWidget;
  `);
}

