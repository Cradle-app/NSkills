import type { z } from 'zod';
import type { ChainAbstractionConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof ChainAbstractionConfig>;

export function generateAbstractionProvider(config: Config): string {
  return dedent(`
    // Chain Abstraction Provider
    // Generated by [N]skills
    
    import { arbitrum, mainnet, optimism, base, type Chain } from 'viem/chains';
    
    export const SUPPORTED_CHAINS: Record<string, Chain> = {
      arbitrum,
      ethereum: mainnet,
      optimism,
      base,
    };
    
    export const ENABLED_CHAINS = [${config.supportedChains.map(c => `'${c}'`).join(', ')}] as const;
    
    export type EnabledChain = typeof ENABLED_CHAINS[number];
    
    export interface ChainBalance {
      chain: EnabledChain;
      chainId: number;
      native: bigint;
      tokens: Array<{
        address: string;
        symbol: string;
        balance: bigint;
        decimals: number;
      }>;
    }
    
    export interface UnifiedBalance {
      totalNative: bigint;
      byChain: Record<EnabledChain, ChainBalance>;
    }
    
    /**
     * Get the chain with the highest balance for a token
     */
    export function getBestChainForToken(
      balances: UnifiedBalance,
      tokenSymbol: string
    ): EnabledChain | null {
      let bestChain: EnabledChain | null = null;
      let highestBalance = 0n;
      
      for (const [chain, balance] of Object.entries(balances.byChain)) {
        const token = balance.tokens.find(t => t.symbol === tokenSymbol);
        if (token && token.balance > highestBalance) {
          highestBalance = token.balance;
          bestChain = chain as EnabledChain;
        }
      }
      
      return bestChain;
    }
    
    /**
     * Get the chain with the lowest gas for a transaction
     */
    export async function getBestChainForGas(
      chains: EnabledChain[]
    ): Promise<EnabledChain> {
      // Simplified: prefer Arbitrum for low gas
      if (chains.includes('arbitrum')) return 'arbitrum';
      if (chains.includes('base')) return 'base';
      if (chains.includes('optimism')) return 'optimism';
      return chains[0];
    }
    
    export const CONFIG = {
      unifiedBalanceEnabled: ${config.unifiedBalanceEnabled},
      autoChainSwitch: ${config.autoChainSwitch},
      gasPaymentToken: '${config.gasPaymentToken}',
    };
  `);
}

export function generateAbstractionHooks(config: Config): string {
  return dedent(`
    // Chain Abstraction Hooks
    // Generated by [N]skills
    
    'use client';
    
    import { useState, useEffect, useCallback, useMemo } from 'react';
    import { useAccount, useBalance, useSwitchChain } from 'wagmi';
    import { formatEther } from 'viem';
    import {
      SUPPORTED_CHAINS,
      ENABLED_CHAINS,
      getBestChainForToken,
      getBestChainForGas,
      CONFIG,
      type EnabledChain,
      type UnifiedBalance,
    } from '@/lib/chain-abstraction/abstraction-provider';
    
    export function useChainAbstraction() {
      const { address, chainId } = useAccount();
      const { switchChain } = useSwitchChain();
      const [unifiedBalance, setUnifiedBalance] = useState<UnifiedBalance | null>(null);
      const [isLoading, setIsLoading] = useState(true);
      
      // Fetch balances across all chains
      useEffect(() => {
        if (!address) {
          setUnifiedBalance(null);
          setIsLoading(false);
          return;
        }
        
        const fetchBalances = async () => {
          setIsLoading(true);
          
          const byChain: Record<string, any> = {};
          let totalNative = 0n;
          
          for (const chainName of ENABLED_CHAINS) {
            const chain = SUPPORTED_CHAINS[chainName];
            if (!chain) continue;
            
            // In real implementation, fetch from each chain's RPC
            // For now, use placeholder
            byChain[chainName] = {
              chain: chainName,
              chainId: chain.id,
              native: 0n,
              tokens: [],
            };
          }
          
          setUnifiedBalance({ totalNative, byChain: byChain as any });
          setIsLoading(false);
        };
        
        fetchBalances();
      }, [address]);
      
      // Switch to the best chain for a transaction
      const switchToBestChain = useCallback(async (
        tokenSymbol?: string
      ) => {
        if (!unifiedBalance || !CONFIG.autoChainSwitch) return;
        
        let targetChain: EnabledChain;
        
        if (tokenSymbol) {
          const best = getBestChainForToken(unifiedBalance, tokenSymbol);
          targetChain = best ?? 'arbitrum';
        } else {
          targetChain = await getBestChainForGas([...ENABLED_CHAINS]);
        }
        
        const chain = SUPPORTED_CHAINS[targetChain];
        if (chain && chainId !== chain.id) {
          await switchChain({ chainId: chain.id });
        }
        
        return targetChain;
      }, [unifiedBalance, chainId, switchChain]);
      
      // Execute on the best chain
      const executeOnBestChain = useCallback(async <T>(
        execute: (chainName: EnabledChain) => Promise<T>,
        preferredToken?: string
      ): Promise<T> => {
        const bestChain = await switchToBestChain(preferredToken);
        return execute(bestChain ?? 'arbitrum');
      }, [switchToBestChain]);
      
      // Get total balance in a readable format
      const formattedTotalBalance = useMemo(() => {
        if (!unifiedBalance) return '0';
        return formatEther(unifiedBalance.totalNative);
      }, [unifiedBalance]);
      
      return {
        unifiedBalance,
        formattedTotalBalance,
        isLoading,
        switchToBestChain,
        executeOnBestChain,
        supportedChains: ENABLED_CHAINS,
        currentChainId: chainId,
      };
    }
    
    export function useUnifiedBalance() {
      const { unifiedBalance, formattedTotalBalance, isLoading } = useChainAbstraction();
      return { balance: unifiedBalance, formatted: formattedTotalBalance, isLoading };
    }
  `);
}

export function generateUnifiedBalance(config: Config): string {
  return dedent(`
    // Unified Balance Component
    // Generated by [N]skills
    
    'use client';
    
    import { formatEther } from 'viem';
    import { useUnifiedBalance } from '@/hooks/useChainAbstraction';
    import { SUPPORTED_CHAINS, ENABLED_CHAINS } from '@/lib/chain-abstraction/abstraction-provider';
    
    interface UnifiedBalanceProps {
      className?: string;
      showBreakdown?: boolean;
    }
    
    export function UnifiedBalance({ className, showBreakdown = true }: UnifiedBalanceProps) {
      const { balance, formatted, isLoading } = useUnifiedBalance();
      
      if (isLoading) {
        return <div className={className}>Loading balances...</div>;
      }
      
      return (
        <div className={className + ' space-y-4'}>
          <div className="p-4 bg-zinc-800 rounded-lg">
            <p className="text-sm text-zinc-400">Total Balance</p>
            <p className="text-2xl font-bold text-white">{formatted} ETH</p>
            <p className="text-xs text-zinc-500 mt-1">
              Across {ENABLED_CHAINS.length} chains
            </p>
          </div>
          
          {showBreakdown && balance && (
            <div className="space-y-2">
              <p className="text-sm text-zinc-400">By Chain</p>
              {ENABLED_CHAINS.map((chainName) => {
                const chainBalance = balance.byChain[chainName];
                const chain = SUPPORTED_CHAINS[chainName];
                
                return (
                  <div
                    key={chainName}
                    className="flex items-center justify-between p-3 bg-zinc-800/50 rounded-md"
                  >
                    <span className="text-sm text-white capitalize">{chainName}</span>
                    <span className="text-sm text-zinc-300 font-mono">
                      {chainBalance ? formatEther(chainBalance.native) : '0'} ETH
                    </span>
                  </div>
                );
              })}
            </div>
          )}
        </div>
      );
    }
    
    export default UnifiedBalance;
  `);
}

