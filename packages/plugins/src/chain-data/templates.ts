import type { z } from 'zod';
import type { ChainDataConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof ChainDataConfig>;

export function generateDataClient(config: Config): string {
  if (config.provider === 'alchemy') {
    return dedent(`
      // Alchemy Data Client
      // Generated by [N]skills
      
      import { Alchemy, Network, type OwnedNft, type TokenBalance } from 'alchemy-sdk';
      import type { Address } from 'viem';
      
      const apiKey = process.env.NEXT_PUBLIC_ALCHEMY_API_KEY;
      
      if (!apiKey) {
        console.warn('Missing NEXT_PUBLIC_ALCHEMY_API_KEY');
      }
      
      export const alchemy = new Alchemy({
        apiKey: apiKey ?? '',
        network: Network.ARB_MAINNET,
      });
      
      export interface TokenData {
        address: Address;
        symbol: string;
        name: string;
        decimals: number;
        balance: string;
        logo?: string;
        price?: number;
      }
      
      export interface NFTData {
        tokenId: string;
        contractAddress: Address;
        name: string;
        description?: string;
        image?: string;
        collection?: string;
      }
      
      export async function getTokenBalances(address: Address): Promise<TokenData[]> {
        const balances = await alchemy.core.getTokenBalances(address);
        
        const tokens: TokenData[] = [];
        for (const balance of balances.tokenBalances) {
          if (balance.tokenBalance === '0x0') continue;
          
          try {
            const metadata = await alchemy.core.getTokenMetadata(balance.contractAddress);
            tokens.push({
              address: balance.contractAddress as Address,
              symbol: metadata.symbol ?? 'UNKNOWN',
              name: metadata.name ?? 'Unknown Token',
              decimals: metadata.decimals ?? 18,
              balance: balance.tokenBalance ?? '0',
              logo: metadata.logo ?? undefined,
            });
          } catch {
            // Skip tokens without metadata
          }
        }
        
        return tokens;
      }
      
      export async function getNFTs(address: Address): Promise<NFTData[]> {
        const nfts = await alchemy.nft.getNftsForOwner(address);
        
        return nfts.ownedNfts.map((nft) => ({
          tokenId: nft.tokenId,
          contractAddress: nft.contract.address as Address,
          name: nft.name ?? \`#\${nft.tokenId}\`,
          description: nft.description,
          image: nft.image?.cachedUrl ?? nft.image?.originalUrl,
          collection: nft.contract.name,
        }));
      }
      
      export async function getTransactionHistory(address: Address, limit = 50) {
        const transfers = await alchemy.core.getAssetTransfers({
          fromAddress: address,
          category: ['external', 'erc20', 'erc721', 'erc1155'],
          maxCount: limit,
          order: 'desc',
        });
        
        return transfers.transfers;
      }
    `);
  }

  // Moralis provider
  return dedent(`
    // Moralis Data Client
    // Generated by [N]skills
    
    import Moralis from 'moralis';
    import type { Address } from 'viem';
    
    const apiKey = process.env.NEXT_PUBLIC_MORALIS_API_KEY;
    
    let initialized = false;
    
    async function initMoralis() {
      if (initialized || !apiKey) return;
      await Moralis.start({ apiKey });
      initialized = true;
    }
    
    export interface TokenData {
      address: Address;
      symbol: string;
      name: string;
      decimals: number;
      balance: string;
      logo?: string;
      price?: number;
    }
    
    export interface NFTData {
      tokenId: string;
      contractAddress: Address;
      name: string;
      description?: string;
      image?: string;
      collection?: string;
    }
    
    export async function getTokenBalances(address: Address): Promise<TokenData[]> {
      await initMoralis();
      
      const response = await Moralis.EvmApi.token.getWalletTokenBalances({
        address,
        chain: '0xa4b1', // Arbitrum
      });
      
      return response.result.map((token) => ({
        address: token.tokenAddress?.lowercase as Address,
        symbol: token.symbol ?? 'UNKNOWN',
        name: token.name ?? 'Unknown Token',
        decimals: token.decimals ?? 18,
        balance: token.balance?.toString() ?? '0',
        logo: token.logo ?? undefined,
      }));
    }
    
    export async function getNFTs(address: Address): Promise<NFTData[]> {
      await initMoralis();
      
      const response = await Moralis.EvmApi.nft.getWalletNFTs({
        address,
        chain: '0xa4b1',
      });
      
      return response.result.map((nft) => ({
        tokenId: nft.tokenId ?? '',
        contractAddress: nft.tokenAddress?.lowercase as Address,
        name: nft.name ?? \`#\${nft.tokenId}\`,
        description: nft.metadata?.description,
        image: nft.metadata?.image,
        collection: nft.name,
      }));
    }
    
    export async function getTransactionHistory(address: Address, limit = 50) {
      await initMoralis();
      
      const response = await Moralis.EvmApi.transaction.getWalletTransactions({
        address,
        chain: '0xa4b1',
        limit,
      });
      
      return response.result;
    }
  `);
}

export function generateDataHooks(config: Config): string {
  return dedent(`
    // Chain Data Hooks
    // Generated by [N]skills
    
    'use client';
    
    import { useQuery, useQueryClient } from '@tanstack/react-query';
    import { useAccount } from 'wagmi';
    import type { Address } from 'viem';
    import {
      getTokenBalances,
      getNFTs,
      getTransactionHistory,
      type TokenData,
      type NFTData,
    } from '@/lib/data/data-client';
    
    const CACHE_TIME = ${config.cacheDuration};
    
    export function useTokenBalances(address?: Address) {
      const { address: connectedAddress } = useAccount();
      const targetAddress = address ?? connectedAddress;
      
      return useQuery({
        queryKey: ['tokenBalances', targetAddress],
        queryFn: () => getTokenBalances(targetAddress!),
        enabled: !!targetAddress,
        staleTime: CACHE_TIME,
        ${config.cacheEnabled ? '' : 'gcTime: 0,'}
      });
    }
    
    export function useNFTs(address?: Address) {
      const { address: connectedAddress } = useAccount();
      const targetAddress = address ?? connectedAddress;
      
      return useQuery({
        queryKey: ['nfts', targetAddress],
        queryFn: () => getNFTs(targetAddress!),
        enabled: !!targetAddress,
        staleTime: CACHE_TIME,
      });
    }
    
    export function useTransactionHistory(address?: Address, limit = 50) {
      const { address: connectedAddress } = useAccount();
      const targetAddress = address ?? connectedAddress;
      
      return useQuery({
        queryKey: ['transactions', targetAddress, limit],
        queryFn: () => getTransactionHistory(targetAddress!, limit),
        enabled: !!targetAddress,
        staleTime: CACHE_TIME,
      });
    }
    
    export function useRefreshData() {
      const queryClient = useQueryClient();
      const { address } = useAccount();
      
      return () => {
        queryClient.invalidateQueries({ queryKey: ['tokenBalances', address] });
        queryClient.invalidateQueries({ queryKey: ['nfts', address] });
        queryClient.invalidateQueries({ queryKey: ['transactions', address] });
      };
    }
  `);
}

export function generateTokenComponents(config: Config): string {
  return dedent(`
    // Token List Component
    // Generated by [N]skills
    
    'use client';
    
    import { formatUnits } from 'viem';
    import { useTokenBalances } from '@/hooks/useChainData';
    import type { TokenData } from '@/lib/data/data-client';
    
    interface TokenListProps {
      className?: string;
    }
    
    export function TokenList({ className }: TokenListProps) {
      const { data: tokens, isLoading, error } = useTokenBalances();
      
      if (isLoading) {
        return <div className={className}>Loading tokens...</div>;
      }
      
      if (error) {
        return <div className={className}>Error loading tokens</div>;
      }
      
      if (!tokens?.length) {
        return <div className={className}>No tokens found</div>;
      }
      
      return (
        <div className={className + ' space-y-2'}>
          {tokens.map((token) => (
            <TokenRow key={token.address} token={token} />
          ))}
        </div>
      );
    }
    
    function TokenRow({ token }: { token: TokenData }) {
      const balance = formatUnits(BigInt(token.balance), token.decimals);
      
      return (
        <div className="flex items-center justify-between p-3 bg-zinc-800 rounded-lg">
          <div className="flex items-center gap-3">
            {token.logo && (
              <img src={token.logo} alt={token.symbol} className="w-8 h-8 rounded-full" />
            )}
            <div>
              <p className="text-white font-medium">{token.symbol}</p>
              <p className="text-xs text-zinc-400">{token.name}</p>
            </div>
          </div>
          <p className="text-white font-mono">{Number(balance).toFixed(4)}</p>
        </div>
      );
    }
    
    export default TokenList;
  `);
}

export function generateNFTComponents(config: Config): string {
  return dedent(`
    // NFT Gallery Component
    // Generated by [N]skills
    
    'use client';
    
    import { useNFTs } from '@/hooks/useChainData';
    import type { NFTData } from '@/lib/data/data-client';
    
    interface NFTGalleryProps {
      className?: string;
      columns?: number;
    }
    
    export function NFTGallery({ className, columns = 3 }: NFTGalleryProps) {
      const { data: nfts, isLoading, error } = useNFTs();
      
      if (isLoading) {
        return <div className={className}>Loading NFTs...</div>;
      }
      
      if (error) {
        return <div className={className}>Error loading NFTs</div>;
      }
      
      if (!nfts?.length) {
        return <div className={className}>No NFTs found</div>;
      }
      
      return (
        <div 
          className={className} 
          style={{ display: 'grid', gridTemplateColumns: \`repeat(\${columns}, 1fr)\`, gap: '1rem' }}
        >
          {nfts.map((nft) => (
            <NFTCard key={\`\${nft.contractAddress}-\${nft.tokenId}\`} nft={nft} />
          ))}
        </div>
      );
    }
    
    function NFTCard({ nft }: { nft: NFTData }) {
      return (
        <div className="bg-zinc-800 rounded-lg overflow-hidden">
          {nft.image ? (
            <img src={nft.image} alt={nft.name} className="w-full aspect-square object-cover" />
          ) : (
            <div className="w-full aspect-square bg-zinc-700 flex items-center justify-center">
              <span className="text-zinc-500">No Image</span>
            </div>
          )}
          <div className="p-3">
            <p className="text-white font-medium truncate">{nft.name}</p>
            {nft.collection && (
              <p className="text-xs text-zinc-400 truncate">{nft.collection}</p>
            )}
          </div>
        </div>
      );
    }
    
    export default NFTGallery;
  `);
}

