import type { z } from 'zod';
import type {
  DuneExecuteSQLConfig,
  DuneTokenPriceConfig,
  DuneWalletBalancesConfig,
  DuneDEXVolumeConfig,
  DuneNFTFloorConfig,
  DuneAddressLabelsConfig,
  DuneTransactionHistoryConfig,
  DuneGasPriceConfig,
  DuneProtocolTVLConfig,
} from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type AnyDuneConfig = 
  | z.infer<typeof DuneExecuteSQLConfig>
  | z.infer<typeof DuneTokenPriceConfig>
  | z.infer<typeof DuneWalletBalancesConfig>
  | z.infer<typeof DuneDEXVolumeConfig>
  | z.infer<typeof DuneNFTFloorConfig>
  | z.infer<typeof DuneAddressLabelsConfig>
  | z.infer<typeof DuneTransactionHistoryConfig>
  | z.infer<typeof DuneGasPriceConfig>
  | z.infer<typeof DuneProtocolTVLConfig>;

// Feature types that can be included in the client
export type DuneFeature = 
  | 'execute-sql'
  | 'token-price'
  | 'wallet-balances'
  | 'dex-volume'
  | 'nft-floor'
  | 'address-labels'
  | 'transaction-history'
  | 'gas-price'
  | 'protocol-tvl';

/**
 * Generate the core Dune API client with ONLY the features needed
 */
export function generateDuneClient(_config: AnyDuneConfig, feature: DuneFeature): string {
  // Base client with core functionality
  const baseClient = generateBaseClient();
  
  // Add only the specific method needed for this feature
  const featureMethod = generateFeatureMethod(feature);
  const featureTypes = generateFeatureTypes(feature);
  
  return dedent(`
    // Dune Analytics API Client
    // Generated by [N]skills - Feature: ${feature}
    
    const DUNE_API_BASE = 'https://api.dune.com/api/v1';
    
    // Core Types
    export interface DuneExecuteParams {
      sql: string;
      performance?: 'medium' | 'large';
      params?: Record<string, string | number>;
    }
    
    export interface DuneExecutionResult {
      execution_id: string;
      state: 'QUERY_STATE_PENDING' | 'QUERY_STATE_EXECUTING' | 'QUERY_STATE_COMPLETED' | 'QUERY_STATE_FAILED' | 'QUERY_STATE_CANCELLED';
    }
    
    export interface DuneQueryResult<T = Record<string, unknown>> {
      execution_id: string;
      query_id: number;
      state: string;
      result: {
        rows: T[];
        metadata: {
          column_names: string[];
          column_types: string[];
          row_count: number;
          result_set_bytes: number;
          total_row_count: number;
        };
      };
    }
    
    ${featureTypes}
    
    class DuneClient {
      private apiKey: string;
      private cache: Map<string, { data: unknown; expiry: number }> = new Map();
    
      constructor() {
        const key = process.env.NEXT_PUBLIC_DUNE_API_KEY ?? process.env.DUNE_API_KEY;
        if (!key) {
          console.warn('Missing DUNE_API_KEY environment variable');
        }
        this.apiKey = key ?? '';
      }
    
      private getCached<T>(key: string): T | null {
        const cached = this.cache.get(key);
        if (cached && cached.expiry > Date.now()) {
          return cached.data as T;
        }
        this.cache.delete(key);
        return null;
      }
    
      private setCache(key: string, data: unknown, ttlMs: number): void {
        this.cache.set(key, { data, expiry: Date.now() + ttlMs });
      }
    
      ${baseClient}
      
      ${featureMethod}
    }
    
    // Export singleton instance
    export const duneClient = new DuneClient();
    
    // Export class for custom instances
    export { DuneClient };
  `);
}

function generateBaseClient(): string {
  return `
  /**
   * Execute a SQL query on Dune
   */
  async executeSQL(params: DuneExecuteParams): Promise<DuneExecutionResult> {
    const response = await fetch(\`\${DUNE_API_BASE}/sql/execute\`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-DUNE-API-KEY': this.apiKey,
      },
      body: JSON.stringify({
        sql: params.sql,
        performance: params.performance ?? 'medium',
        ...(params.params && { query_parameters: params.params }),
      }),
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Dune API error: \${response.status} - \${error}\`);
    }

    return response.json();
  }

  /**
   * Get execution status
   */
  async getExecutionStatus(executionId: string): Promise<DuneExecutionResult> {
    const response = await fetch(\`\${DUNE_API_BASE}/execution/\${executionId}/status\`, {
      headers: {
        'X-DUNE-API-KEY': this.apiKey,
      },
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Dune API error: \${response.status} - \${error}\`);
    }

    return response.json();
  }

  /**
   * Get execution results
   */
  async getExecutionResults<T = Record<string, unknown>>(executionId: string): Promise<DuneQueryResult<T>> {
    const response = await fetch(\`\${DUNE_API_BASE}/execution/\${executionId}/results\`, {
      headers: {
        'X-DUNE-API-KEY': this.apiKey,
      },
    });

    if (!response.ok) {
      const error = await response.text();
      throw new Error(\`Dune API error: \${response.status} - \${error}\`);
    }

    return response.json();
  }

  /**
   * Execute query and wait for results
   */
  async executeAndWait<T = Record<string, unknown>>(
    params: DuneExecuteParams,
    options?: { pollInterval?: number; timeout?: number; cacheTtl?: number }
  ): Promise<DuneQueryResult<T>> {
    const cacheKey = JSON.stringify(params);
    const cached = this.getCached<DuneQueryResult<T>>(cacheKey);
    if (cached) return cached;

    const pollInterval = options?.pollInterval ?? 1000;
    const timeout = options?.timeout ?? 60000;
    const startTime = Date.now();

    const execution = await this.executeSQL(params);
    
    while (Date.now() - startTime < timeout) {
      const status = await this.getExecutionStatus(execution.execution_id);
      
      if (status.state === 'QUERY_STATE_COMPLETED') {
        const results = await this.getExecutionResults<T>(execution.execution_id);
        if (options?.cacheTtl) {
          this.setCache(cacheKey, results, options.cacheTtl);
        }
        return results;
      }
      
      if (status.state === 'QUERY_STATE_FAILED' || status.state === 'QUERY_STATE_CANCELLED') {
        throw new Error(\`Query \${status.state}\`);
      }
      
      await new Promise(resolve => setTimeout(resolve, pollInterval));
    }

    throw new Error('Query execution timeout');
  }`;
}

function generateFeatureTypes(feature: DuneFeature): string {
  switch (feature) {
    case 'execute-sql':
      return ''; // No extra types needed for execute-sql
    
    case 'token-price':
      return `
export interface TokenPrice {
  blockchain: string;
  contract_address: string;
  symbol: string;
  price: number;
  decimals: number;
  timestamp: string;
}`;

    case 'wallet-balances':
      return `
export interface WalletBalance {
  token_address: string;
  symbol: string;
  balance: number;
  value_usd: number;
}`;

    case 'dex-volume':
      return `
export interface DEXVolume {
  date: string;
  volume_usd: number;
  trade_count: number;
}`;

    case 'nft-floor':
      return `
export interface NFTFloorData {
  collection_address: string;
  floor_price_eth: number;
  floor_price_usd: number;
  volume_24h: number;
  sales_count_24h: number;
  timestamp: string;
}`;

    case 'address-labels':
      return `
export interface AddressLabel {
  address: string;
  ens_name: string | null;
  labels: string[];
  category: string | null;
  owner: string | null;
}`;

    case 'transaction-history':
      return `
export interface Transaction {
  hash: string;
  block_number: number;
  timestamp: string;
  from: string;
  to: string;
  value: number;
  gas_used: number;
  direction: 'sent' | 'received' | 'self';
}`;

    case 'gas-price':
      return `
export interface GasPriceData {
  blockchain: string;
  current_gas_price_gwei: number;
  avg_gas_price_24h: number;
  median_gas_price_24h: number;
  min_gas_price_24h: number;
  max_gas_price_24h: number;
  timestamp: string;
}`;

    case 'protocol-tvl':
      return `
export interface ProtocolTVL {
  protocol: string;
  blockchain: string;
  tvl_usd: number;
  change_24h_percent: number;
  timestamp: string;
}`;

    default:
      return '';
  }
}

function generateFeatureMethod(feature: DuneFeature): string {
  switch (feature) {
    case 'execute-sql':
      return ''; // Base client already has executeAndWait
    
    case 'token-price':
      return `
  /**
   * Get latest token price
   */
  async getTokenPrice(blockchain: string, contractAddress: string, cacheTtl = 60000): Promise<TokenPrice | null> {
    const sql = \`
      SELECT 
        blockchain,
        contract_address,
        symbol,
        price,
        decimals,
        timestamp
      FROM prices.latest
      WHERE blockchain = '\${blockchain}'
        AND contract_address = LOWER('\${contractAddress}')
    \`;

    const result = await this.executeAndWait<TokenPrice>({ sql }, { cacheTtl });
    return result.result.rows[0] ?? null;
  }`;

    case 'wallet-balances':
      return `
  /**
   * Get wallet token balances
   */
  async getWalletBalances(
    wallet: string,
    blockchain: string,
    minBalanceUsd = 1,
    cacheTtl = 60000
  ): Promise<WalletBalance[]> {
    const sql = \`
      SELECT 
        b.token_address,
        m.symbol,
        CAST(b.balance AS DOUBLE) / POWER(10, COALESCE(m.decimals, 18)) as balance,
        (CAST(b.balance AS DOUBLE) / POWER(10, COALESCE(m.decimals, 18))) * COALESCE(p.price, 0) as value_usd
      FROM balances.erc20 b
      LEFT JOIN tokens.erc20 m ON b.token_address = m.contract_address AND b.blockchain = m.blockchain
      LEFT JOIN prices.latest p ON b.token_address = p.contract_address AND b.blockchain = p.blockchain
      WHERE b.address = LOWER('\${wallet}')
        AND b.blockchain = '\${blockchain}'
        AND (CAST(b.balance AS DOUBLE) / POWER(10, COALESCE(m.decimals, 18))) * COALESCE(p.price, 0) >= \${minBalanceUsd}
      ORDER BY value_usd DESC
    \`;

    const result = await this.executeAndWait<WalletBalance>({ sql }, { cacheTtl });
    return result.result.rows;
  }`;

    case 'dex-volume':
      return `
  /**
   * Get DEX trading volume
   */
  async getDEXVolume(
    blockchain: string,
    days = 7,
    protocol?: string,
    cacheTtl = 300000
  ): Promise<DEXVolume[]> {
    const protocolFilter = protocol ? \`AND project = '\${protocol}'\` : '';
    const sql = \`
      SELECT 
        DATE(block_time) as date,
        SUM(amount_usd) as volume_usd,
        COUNT(*) as trade_count
      FROM dex.trades
      WHERE blockchain = '\${blockchain}'
        AND block_time >= NOW() - INTERVAL '\${days}' DAY
        \${protocolFilter}
      GROUP BY DATE(block_time)
      ORDER BY date
    \`;

    const result = await this.executeAndWait<DEXVolume>({ sql }, { cacheTtl });
    return result.result.rows;
  }`;

    case 'nft-floor':
      return `
  /**
   * Get NFT collection floor price
   */
  async getNFTFloor(
    collectionAddress: string,
    blockchain: string,
    cacheTtl = 300000
  ): Promise<NFTFloorData | null> {
    const sql = \`
      SELECT 
        nft_contract_address as collection_address,
        MIN(amount_raw / 1e18) as floor_price_eth,
        MIN(amount_usd) as floor_price_usd,
        SUM(CASE WHEN block_time >= NOW() - INTERVAL '24' HOUR THEN amount_usd ELSE 0 END) as volume_24h,
        COUNT(CASE WHEN block_time >= NOW() - INTERVAL '24' HOUR THEN 1 END) as sales_count_24h,
        MAX(block_time) as timestamp
      FROM nft.trades
      WHERE nft_contract_address = LOWER('\${collectionAddress}')
        AND blockchain = '\${blockchain}'
        AND block_time >= NOW() - INTERVAL '7' DAY
      GROUP BY nft_contract_address
    \`;

    const result = await this.executeAndWait<NFTFloorData>({ sql }, { cacheTtl });
    return result.result.rows[0] ?? null;
  }`;

    case 'address-labels':
      return `
  /**
   * Get address labels
   */
  async getAddressLabels(address: string, cacheTtl = 86400000): Promise<AddressLabel> {
    const sql = \`
      SELECT 
        a.address,
        e.name as ens_name,
        ARRAY_AGG(DISTINCT a.name) as labels,
        MAX(a.category) as category,
        MAX(o.owner_name) as owner
      FROM labels.addresses a
      LEFT JOIN labels.ens e ON LOWER(a.address) = LOWER(e.address)
      LEFT JOIN labels.owner_addresses o ON LOWER(a.address) = LOWER(o.address)
      WHERE LOWER(a.address) = LOWER('\${address}')
      GROUP BY a.address, e.name
    \`;

    const result = await this.executeAndWait<AddressLabel>({ sql }, { cacheTtl });
    return result.result.rows[0] ?? {
      address,
      ens_name: null,
      labels: [],
      category: null,
      owner: null,
    };
  }`;

    case 'transaction-history':
      return `
  /**
   * Get transaction history
   */
  async getTransactionHistory(
    address: string,
    blockchain: string,
    limit = 100,
    cacheTtl = 60000
  ): Promise<Transaction[]> {
    const sql = \`
      SELECT 
        hash,
        block_number,
        block_time as timestamp,
        "from" as sender,
        "to" as receiver,
        CAST(value AS DOUBLE) / 1e18 as value,
        gas_used,
        CASE 
          WHEN LOWER("from") = LOWER('\${address}') AND LOWER("to") = LOWER('\${address}') THEN 'self'
          WHEN LOWER("from") = LOWER('\${address}') THEN 'sent'
          ELSE 'received'
        END as direction
      FROM \${blockchain}.transactions
      WHERE (LOWER("from") = LOWER('\${address}') OR LOWER("to") = LOWER('\${address}'))
        AND success = true
      ORDER BY block_time DESC
      LIMIT \${limit}
    \`;

    const result = await this.executeAndWait<Transaction>({ sql }, { cacheTtl });
    return result.result.rows;
  }`;

    case 'gas-price':
      return `
  /**
   * Get gas price analytics
   */
  async getGasPrice(blockchain: string, cacheTtl = 60000): Promise<GasPriceData> {
    const sql = \`
      SELECT 
        '\${blockchain}' as blockchain,
        AVG(gas_price / 1e9) as avg_gas_price_24h,
        APPROX_PERCENTILE(gas_price / 1e9, 0.5) as median_gas_price_24h,
        MIN(gas_price / 1e9) as min_gas_price_24h,
        MAX(gas_price / 1e9) as max_gas_price_24h,
        NOW() as timestamp
      FROM \${blockchain}.transactions
      WHERE block_time >= NOW() - INTERVAL '24' HOUR
    \`;

    const result = await this.executeAndWait<GasPriceData>({ sql }, { cacheTtl });
    const data = result.result.rows[0];
    return {
      ...data,
      current_gas_price_gwei: data.median_gas_price_24h,
    };
  }`;

    case 'protocol-tvl':
      return `
  /**
   * Get protocol TVL
   */
  async getProtocolTVL(
    protocol: string,
    blockchain: string,
    cacheTtl = 600000
  ): Promise<ProtocolTVL | null> {
    const sql = \`
      SELECT 
        '\${protocol}' as protocol,
        '\${blockchain}' as blockchain,
        SUM(CAST(value AS DOUBLE) / 1e18 * COALESCE(p.price, 0)) as tvl_usd,
        0 as change_24h_percent,
        NOW() as timestamp
      FROM \${blockchain}.transactions t
      LEFT JOIN prices.latest p ON p.blockchain = '\${blockchain}' AND p.symbol = 'ETH'
      WHERE "to" IN (
        SELECT address FROM \${blockchain}.contracts WHERE namespace = '\${protocol}'
      )
      AND block_time >= NOW() - INTERVAL '7' DAY
    \`;

    try {
      const result = await this.executeAndWait<ProtocolTVL>({ sql }, { cacheTtl });
      return result.result.rows[0] ?? null;
    } catch {
      return null;
    }
  }`;

    default:
      return '';
  }
}

/**
 * Generate React hooks for specific Dune feature
 */
export function generateDuneHooks(_config: AnyDuneConfig, hookType?: string): string {
  if (hookType === 'token-price') {
    return generateTokenPriceHook();
  }
  if (hookType === 'wallet-balances') {
    return generateWalletBalancesHook();
  }
  if (hookType === 'dex-volume') {
    return generateDEXVolumeHook();
  }
  if (hookType === 'nft-floor') {
    return generateNFTFloorHook();
  }
  if (hookType === 'address-labels') {
    return generateAddressLabelsHook();
  }
  if (hookType === 'transaction-history') {
    return generateTransactionHistoryHook();
  }
  if (hookType === 'gas-price') {
    return generateGasPriceHook();
  }
  if (hookType === 'protocol-tvl') {
    return generateProtocolTVLHook();
  }

  // Default: generic query hook for execute-sql
  return dedent(`
    // Dune Query Hook
    // Generated by [N]skills
    
    'use client';
    
    import { useState, useCallback } from 'react';
    import { useQuery, useMutation } from '@tanstack/react-query';
    import { duneClient, type DuneExecuteParams, type DuneQueryResult } from '@/lib/dune-client';
    
    export interface UseDuneQueryOptions {
      enabled?: boolean;
      refetchInterval?: number;
    }
    
    export function useDuneQuery<T = Record<string, unknown>>(
      params?: DuneExecuteParams,
      options?: UseDuneQueryOptions
    ) {
      return useQuery({
        queryKey: ['dune-query', params?.sql],
        queryFn: () => duneClient.executeAndWait<T>(params!),
        enabled: !!params?.sql && (options?.enabled ?? true),
        refetchInterval: options?.refetchInterval,
      });
    }
    
    export function useDuneMutation<T = Record<string, unknown>>() {
      return useMutation({
        mutationFn: (params: DuneExecuteParams) => duneClient.executeAndWait<T>(params),
      });
    }
    
    export function useDuneLazyQuery<T = Record<string, unknown>>() {
      const [data, setData] = useState<DuneQueryResult<T> | null>(null);
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<Error | null>(null);
    
      const execute = useCallback(async (params: DuneExecuteParams) => {
        setIsLoading(true);
        setError(null);
        try {
          const result = await duneClient.executeAndWait<T>(params);
          setData(result);
          return result;
        } catch (err) {
          setError(err as Error);
          throw err;
        } finally {
          setIsLoading(false);
        }
      }, []);
    
      return { data, isLoading, error, execute };
    }
  `);
}

function generateTokenPriceHook(): string {
  return dedent(`
    // Token Price Hook
    // Generated by [N]skills
    
    'use client';
    
    import { useQuery } from '@tanstack/react-query';
    import { duneClient, type TokenPrice } from '@/lib/dune-client';
    
    export interface UseTokenPriceParams {
      blockchain: string;
      contractAddress: string;
      enabled?: boolean;
      refetchInterval?: number;
    }
    
    export function useTokenPrice(params: UseTokenPriceParams) {
      return useQuery({
        queryKey: ['dune-token-price', params.blockchain, params.contractAddress],
        queryFn: () => duneClient.getTokenPrice(params.blockchain, params.contractAddress),
        enabled: params.enabled ?? true,
        refetchInterval: params.refetchInterval ?? 60000,
        staleTime: 30000,
      });
    }
    
    export function useMultipleTokenPrices(
      tokens: Array<{ blockchain: string; contractAddress: string }>,
      options?: { enabled?: boolean; refetchInterval?: number }
    ) {
      return useQuery({
        queryKey: ['dune-token-prices', tokens],
        queryFn: async () => {
          const results = await Promise.all(
            tokens.map(t => duneClient.getTokenPrice(t.blockchain, t.contractAddress))
          );
          return results.filter((r): r is TokenPrice => r !== null);
        },
        enabled: options?.enabled ?? true,
        refetchInterval: options?.refetchInterval ?? 60000,
      });
    }
  `);
}

function generateWalletBalancesHook(): string {
  return dedent(`
    // Wallet Balances Hook
    // Generated by [N]skills
    
    'use client';
    
    import { useQuery } from '@tanstack/react-query';
    import { useAccount } from 'wagmi';
    import { duneClient, type WalletBalance } from '@/lib/dune-client';
    
    export interface UseWalletBalancesParams {
      address?: string;
      blockchain?: string;
      minBalanceUsd?: number;
      enabled?: boolean;
    }
    
    export function useWalletBalances(params?: UseWalletBalancesParams) {
      const { address: connectedAddress } = useAccount();
      const targetAddress = params?.address ?? connectedAddress;
    
      return useQuery({
        queryKey: ['dune-wallet-balances', targetAddress, params?.blockchain, params?.minBalanceUsd],
        queryFn: () => duneClient.getWalletBalances(
          targetAddress!,
          params?.blockchain ?? 'arbitrum',
          params?.minBalanceUsd ?? 1
        ),
        enabled: !!targetAddress && (params?.enabled ?? true),
        staleTime: 60000,
      });
    }
    
    export function usePortfolioValue(params?: UseWalletBalancesParams) {
      const { data: balances, ...rest } = useWalletBalances(params);
      
      const totalValue = balances?.reduce((sum, b) => sum + b.value_usd, 0) ?? 0;
    
      return {
        ...rest,
        balances,
        totalValue,
      };
    }
  `);
}

function generateDEXVolumeHook(): string {
  return dedent(`
    // DEX Volume Hook
    // Generated by [N]skills
    
    'use client';
    
    import { useQuery } from '@tanstack/react-query';
    import { duneClient, type DEXVolume } from '@/lib/dune-client';
    
    export interface UseDEXVolumeParams {
      blockchain?: string;
      days?: number;
      protocol?: string;
      enabled?: boolean;
    }
    
    export function useDEXVolume(params?: UseDEXVolumeParams) {
      return useQuery({
        queryKey: ['dune-dex-volume', params?.blockchain, params?.days, params?.protocol],
        queryFn: () => duneClient.getDEXVolume(
          params?.blockchain ?? 'arbitrum',
          params?.days ?? 7,
          params?.protocol
        ),
        enabled: params?.enabled ?? true,
        staleTime: 300000,
      });
    }
    
    export function useDEXVolumeStats(params?: UseDEXVolumeParams) {
      const { data: volumes, ...rest } = useDEXVolume(params);
      
      const totalVolume = volumes?.reduce((sum, v) => sum + v.volume_usd, 0) ?? 0;
      const totalTrades = volumes?.reduce((sum, v) => sum + v.trade_count, 0) ?? 0;
      const avgDailyVolume = volumes?.length ? totalVolume / volumes.length : 0;
    
      return {
        ...rest,
        volumes,
        totalVolume,
        totalTrades,
        avgDailyVolume,
      };
    }
  `);
}

function generateNFTFloorHook(): string {
  return dedent(`
    // NFT Floor Price Hook
    // Generated by [N]skills
    
    'use client';
    
    import { useQuery } from '@tanstack/react-query';
    import { duneClient, type NFTFloorData } from '@/lib/dune-client';
    
    export interface UseNFTFloorParams {
      collectionAddress: string;
      blockchain?: string;
      enabled?: boolean;
    }
    
    export function useNFTFloor(params: UseNFTFloorParams) {
      return useQuery({
        queryKey: ['dune-nft-floor', params.collectionAddress, params.blockchain],
        queryFn: () => duneClient.getNFTFloor(
          params.collectionAddress,
          params.blockchain ?? 'ethereum'
        ),
        enabled: !!params.collectionAddress && (params.enabled ?? true),
        staleTime: 300000,
      });
    }
  `);
}

function generateAddressLabelsHook(): string {
  return dedent(`
    // Address Labels Hook
    // Generated by [N]skills
    
    'use client';
    
    import { useQuery } from '@tanstack/react-query';
    import { duneClient, type AddressLabel } from '@/lib/dune-client';
    
    export function useAddressLabels(address?: string) {
      return useQuery({
        queryKey: ['dune-address-labels', address],
        queryFn: () => duneClient.getAddressLabels(address!),
        enabled: !!address,
        staleTime: 86400000, // 24 hours
      });
    }
    
    export function useAddressDisplay(address?: string) {
      const { data: labels, isLoading } = useAddressLabels(address);
      
      const displayName = labels?.ens_name 
        ?? labels?.labels?.[0] 
        ?? (address ? \`\${address.slice(0, 6)}...\${address.slice(-4)}\` : '');
    
      return {
        displayName,
        labels,
        isLoading,
      };
    }
  `);
}

function generateTransactionHistoryHook(): string {
  return dedent(`
    // Transaction History Hook
    // Generated by [N]skills
    
    'use client';
    
    import { useQuery } from '@tanstack/react-query';
    import { useAccount } from 'wagmi';
    import { duneClient, type Transaction } from '@/lib/dune-client';
    
    export interface UseTransactionHistoryParams {
      address?: string;
      blockchain?: string;
      limit?: number;
      enabled?: boolean;
    }
    
    export function useTransactionHistory(params?: UseTransactionHistoryParams) {
      const { address: connectedAddress } = useAccount();
      const targetAddress = params?.address ?? connectedAddress;
    
      return useQuery({
        queryKey: ['dune-tx-history', targetAddress, params?.blockchain, params?.limit],
        queryFn: () => duneClient.getTransactionHistory(
          targetAddress!,
          params?.blockchain ?? 'arbitrum',
          params?.limit ?? 100
        ),
        enabled: !!targetAddress && (params?.enabled ?? true),
        staleTime: 60000,
      });
    }
  `);
}

function generateGasPriceHook(): string {
  return dedent(`
    // Gas Price Hook
    // Generated by [N]skills
    
    'use client';
    
    import { useQuery } from '@tanstack/react-query';
    import { duneClient, type GasPriceData } from '@/lib/dune-client';
    
    export interface UseGasPriceParams {
      blockchain?: string;
      enabled?: boolean;
      refetchInterval?: number;
    }
    
    export function useGasPrice(params?: UseGasPriceParams) {
      return useQuery({
        queryKey: ['dune-gas-price', params?.blockchain],
        queryFn: () => duneClient.getGasPrice(params?.blockchain ?? 'arbitrum'),
        enabled: params?.enabled ?? true,
        refetchInterval: params?.refetchInterval ?? 60000,
        staleTime: 30000,
      });
    }
  `);
}

function generateProtocolTVLHook(): string {
  return dedent(`
    // Protocol TVL Hook
    // Generated by [N]skills
    
    'use client';
    
    import { useQuery } from '@tanstack/react-query';
    import { duneClient, type ProtocolTVL } from '@/lib/dune-client';
    
    export interface UseProtocolTVLParams {
      protocol: string;
      blockchain?: string;
      enabled?: boolean;
    }
    
    export function useProtocolTVL(params: UseProtocolTVLParams) {
      return useQuery({
        queryKey: ['dune-protocol-tvl', params.protocol, params.blockchain],
        queryFn: () => duneClient.getProtocolTVL(
          params.protocol,
          params.blockchain ?? 'arbitrum'
        ),
        enabled: !!params.protocol && (params.enabled ?? true),
        staleTime: 600000,
      });
    }
  `);
}

// Component generators
export function generateTokenPriceComponent(_config: AnyDuneConfig): string {
  return dedent(`
    // Token Price Card Component
    // Generated by [N]skills
    
    'use client';
    
    import { useTokenPrice } from '@/hooks/useTokenPrice';
    
    interface TokenPriceCardProps {
      blockchain: string;
      contractAddress: string;
      className?: string;
    }
    
    export function TokenPriceCard({ blockchain, contractAddress, className }: TokenPriceCardProps) {
      const { data: price, isLoading, error } = useTokenPrice({ blockchain, contractAddress });
    
      if (isLoading) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 animate-pulse \${className}\`}>
            <div className="h-4 bg-zinc-700 rounded w-1/3 mb-2" />
            <div className="h-8 bg-zinc-700 rounded w-1/2" />
          </div>
        );
      }
    
      if (error || !price) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-red-500/30 \${className}\`}>
            <p className="text-red-400 text-sm">Failed to load price</p>
          </div>
        );
      }
    
      return (
        <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 \${className}\`}>
          <div className="flex items-center justify-between mb-2">
            <span className="text-sm text-zinc-400">{price.symbol}</span>
            <span className="text-xs text-zinc-500">{price.blockchain}</span>
          </div>
          <p className="text-2xl font-bold text-white">
            \${price.price.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 6 })}
          </p>
        </div>
      );
    }
    
    export default TokenPriceCard;
  `);
}

export function generateWalletBalancesComponent(_config: AnyDuneConfig): string {
  return dedent(`
    // Wallet Balances Component
    // Generated by [N]skills
    
    'use client';
    
    import { useWalletBalances, usePortfolioValue } from '@/hooks/useWalletBalances';
    
    interface WalletBalancesProps {
      address?: string;
      blockchain?: string;
      className?: string;
    }
    
    export function WalletBalances({ address, blockchain, className }: WalletBalancesProps) {
      const { balances, totalValue, isLoading, error } = usePortfolioValue({ address, blockchain });
    
      if (isLoading) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 \${className}\`}>
            <div className="animate-pulse space-y-3">
              <div className="h-6 bg-zinc-700 rounded w-1/3" />
              <div className="h-4 bg-zinc-700 rounded w-full" />
              <div className="h-4 bg-zinc-700 rounded w-2/3" />
            </div>
          </div>
        );
      }
    
      if (error) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-red-500/30 \${className}\`}>
            <p className="text-red-400 text-sm">Failed to load balances</p>
          </div>
        );
      }
    
      return (
        <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 \${className}\`}>
          <div className="flex items-center justify-between mb-4">
            <h3 className="text-sm font-medium text-zinc-400">Portfolio Value</h3>
            <span className="text-lg font-bold text-white">
              \${totalValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}
            </span>
          </div>
          <div className="space-y-2">
            {balances?.slice(0, 5).map((balance, i) => (
              <div key={i} className="flex items-center justify-between text-sm">
                <span className="text-zinc-300">{balance.symbol}</span>
                <span className="text-zinc-400">
                  \${balance.value_usd.toLocaleString(undefined, { minimumFractionDigits: 2 })}
                </span>
              </div>
            ))}
            {balances && balances.length > 5 && (
              <p className="text-xs text-zinc-500 text-center pt-2">
                +{balances.length - 5} more tokens
              </p>
            )}
          </div>
        </div>
      );
    }
    
    export default WalletBalances;
  `);
}

export function generateDEXVolumeComponent(_config: AnyDuneConfig): string {
  return dedent(`
    // DEX Volume Chart Component
    // Generated by [N]skills
    
    'use client';
    
    import { useDEXVolumeStats } from '@/hooks/useDEXVolume';
    
    interface DEXVolumeChartProps {
      blockchain?: string;
      days?: number;
      protocol?: string;
      className?: string;
    }
    
    export function DEXVolumeChart({ blockchain, days, protocol, className }: DEXVolumeChartProps) {
      const { volumes, totalVolume, totalTrades, isLoading, error } = useDEXVolumeStats({ 
        blockchain, 
        days, 
        protocol 
      });
    
      if (isLoading) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 \${className}\`}>
            <div className="animate-pulse space-y-3">
              <div className="h-6 bg-zinc-700 rounded w-1/3" />
              <div className="h-32 bg-zinc-700 rounded" />
            </div>
          </div>
        );
      }
    
      if (error) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-red-500/30 \${className}\`}>
            <p className="text-red-400 text-sm">Failed to load volume data</p>
          </div>
        );
      }
    
      return (
        <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 \${className}\`}>
          <h3 className="text-sm font-medium text-zinc-400 mb-4">DEX Volume</h3>
          <div className="grid grid-cols-2 gap-4 mb-4">
            <div>
              <p className="text-xs text-zinc-500">Total Volume</p>
              <p className="text-lg font-bold text-white">
                \${(totalVolume / 1e6).toFixed(2)}M
              </p>
            </div>
            <div>
              <p className="text-xs text-zinc-500">Total Trades</p>
              <p className="text-lg font-bold text-white">
                {totalTrades.toLocaleString()}
              </p>
            </div>
          </div>
          <div className="h-32 flex items-end gap-1">
            {volumes?.map((v, i) => {
              const maxVol = Math.max(...(volumes?.map(x => x.volume_usd) ?? [1]));
              const height = (v.volume_usd / maxVol) * 100;
              return (
                <div
                  key={i}
                  className="flex-1 bg-cyan-500/60 rounded-t hover:bg-cyan-500 transition-colors"
                  style={{ height: \`\${Math.max(height, 4)}%\` }}
                  title={\`\${v.date}: \$\${v.volume_usd.toLocaleString()}\`}
                />
              );
            })}
          </div>
        </div>
      );
    }
    
    export default DEXVolumeChart;
  `);
}

export function generateNFTFloorComponent(_config: AnyDuneConfig): string {
  return dedent(`
    // NFT Floor Price Card Component
    // Generated by [N]skills
    
    'use client';
    
    import { useNFTFloor } from '@/hooks/useNFTFloor';
    
    interface NFTFloorCardProps {
      collectionAddress: string;
      blockchain?: string;
      className?: string;
    }
    
    export function NFTFloorCard({ collectionAddress, blockchain, className }: NFTFloorCardProps) {
      const { data: floor, isLoading, error } = useNFTFloor({ collectionAddress, blockchain });
    
      if (isLoading) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 animate-pulse \${className}\`}>
            <div className="h-4 bg-zinc-700 rounded w-1/3 mb-2" />
            <div className="h-8 bg-zinc-700 rounded w-1/2" />
          </div>
        );
      }
    
      if (error || !floor) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-red-500/30 \${className}\`}>
            <p className="text-red-400 text-sm">Failed to load floor price</p>
          </div>
        );
      }
    
      return (
        <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 \${className}\`}>
          <h3 className="text-sm font-medium text-zinc-400 mb-2">Floor Price</h3>
          <p className="text-2xl font-bold text-white">
            {floor.floor_price_eth.toFixed(4)} ETH
          </p>
          <p className="text-sm text-zinc-500">
            \${floor.floor_price_usd.toLocaleString()}
          </p>
          <div className="mt-3 pt-3 border-t border-zinc-700/50 grid grid-cols-2 gap-4 text-xs">
            <div>
              <p className="text-zinc-500">24h Volume</p>
              <p className="text-zinc-300">\${floor.volume_24h.toLocaleString()}</p>
            </div>
            <div>
              <p className="text-zinc-500">24h Sales</p>
              <p className="text-zinc-300">{floor.sales_count_24h}</p>
            </div>
          </div>
        </div>
      );
    }
    
    export default NFTFloorCard;
  `);
}

export function generateAddressLabelsComponent(_config: AnyDuneConfig): string {
  return dedent(`
    // Address Label Component
    // Generated by [N]skills
    
    'use client';
    
    import { useAddressDisplay } from '@/hooks/useAddressLabels';
    
    interface AddressLabelProps {
      address: string;
      showFullOnHover?: boolean;
      className?: string;
    }
    
    export function AddressLabel({ address, showFullOnHover = true, className }: AddressLabelProps) {
      const { displayName, labels, isLoading } = useAddressDisplay(address);
    
      if (isLoading) {
        return (
          <span className={\`inline-block h-4 w-24 bg-zinc-700 rounded animate-pulse \${className}\`} />
        );
      }
    
      return (
        <span 
          className={\`inline-flex items-center gap-1 text-sm \${className}\`}
          title={showFullOnHover ? address : undefined}
        >
          <span className="text-zinc-300">{displayName}</span>
          {labels?.category && (
            <span className="px-1.5 py-0.5 text-xs bg-zinc-700 text-zinc-400 rounded">
              {labels.category}
            </span>
          )}
        </span>
      );
    }
    
    export default AddressLabel;
  `);
}

export function generateTransactionHistoryComponent(_config: AnyDuneConfig): string {
  return dedent(`
    // Transaction History Component
    // Generated by [N]skills
    
    'use client';
    
    import { useTransactionHistory } from '@/hooks/useTransactionHistory';
    
    interface TransactionHistoryProps {
      address?: string;
      blockchain?: string;
      limit?: number;
      className?: string;
    }
    
    export function TransactionHistory({ address, blockchain, limit, className }: TransactionHistoryProps) {
      const { data: transactions, isLoading, error } = useTransactionHistory({ 
        address, 
        blockchain, 
        limit 
      });
    
      if (isLoading) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 \${className}\`}>
            <div className="animate-pulse space-y-3">
              {[1, 2, 3].map(i => (
                <div key={i} className="h-12 bg-zinc-700 rounded" />
              ))}
            </div>
          </div>
        );
      }
    
      if (error) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-red-500/30 \${className}\`}>
            <p className="text-red-400 text-sm">Failed to load transactions</p>
          </div>
        );
      }
    
      return (
        <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 \${className}\`}>
          <h3 className="text-sm font-medium text-zinc-400 mb-4">Recent Transactions</h3>
          <div className="space-y-2">
            {transactions?.slice(0, 10).map((tx, i) => (
              <div key={i} className="flex items-center justify-between p-2 rounded-lg bg-zinc-900/50">
                <div className="flex items-center gap-2">
                  <span className={\`w-2 h-2 rounded-full \${
                    tx.direction === 'sent' ? 'bg-red-400' :
                    tx.direction === 'received' ? 'bg-green-400' : 'bg-yellow-400'
                  }\`} />
                  <span className="text-xs text-zinc-500 font-mono">
                    {tx.hash.slice(0, 8)}...
                  </span>
                </div>
                <span className={\`text-sm \${
                  tx.direction === 'sent' ? 'text-red-400' : 'text-green-400'
                }\`}>
                  {tx.direction === 'sent' ? '-' : '+'}{tx.value.toFixed(4)} ETH
                </span>
              </div>
            ))}
          </div>
        </div>
      );
    }
    
    export default TransactionHistory;
  `);
}

export function generateGasPriceComponent(_config: AnyDuneConfig): string {
  return dedent(`
    // Gas Price Card Component
    // Generated by [N]skills
    
    'use client';
    
    import { useGasPrice } from '@/hooks/useGasPrice';
    
    interface GasPriceCardProps {
      blockchain?: string;
      className?: string;
    }
    
    export function GasPriceCard({ blockchain, className }: GasPriceCardProps) {
      const { data: gasData, isLoading, error } = useGasPrice({ blockchain });
    
      if (isLoading) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 animate-pulse \${className}\`}>
            <div className="h-4 bg-zinc-700 rounded w-1/3 mb-2" />
            <div className="h-8 bg-zinc-700 rounded w-1/2" />
          </div>
        );
      }
    
      if (error || !gasData) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-red-500/30 \${className}\`}>
            <p className="text-red-400 text-sm">Failed to load gas prices</p>
          </div>
        );
      }
    
      return (
        <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 \${className}\`}>
          <div className="flex items-center justify-between mb-2">
            <h3 className="text-sm font-medium text-zinc-400">Gas Price</h3>
            <span className="text-xs text-zinc-500">{gasData.blockchain}</span>
          </div>
          <p className="text-2xl font-bold text-white">
            {gasData.current_gas_price_gwei.toFixed(2)} Gwei
          </p>
          <div className="mt-3 grid grid-cols-3 gap-2 text-xs">
            <div>
              <p className="text-zinc-500">Low</p>
              <p className="text-green-400">{gasData.min_gas_price_24h.toFixed(1)}</p>
            </div>
            <div>
              <p className="text-zinc-500">Avg</p>
              <p className="text-yellow-400">{gasData.avg_gas_price_24h.toFixed(1)}</p>
            </div>
            <div>
              <p className="text-zinc-500">High</p>
              <p className="text-red-400">{gasData.max_gas_price_24h.toFixed(1)}</p>
            </div>
          </div>
        </div>
      );
    }
    
    export default GasPriceCard;
  `);
}

export function generateProtocolTVLComponent(_config: AnyDuneConfig): string {
  return dedent(`
    // Protocol TVL Card Component
    // Generated by [N]skills
    
    'use client';
    
    import { useProtocolTVL } from '@/hooks/useProtocolTVL';
    
    interface ProtocolTVLCardProps {
      protocol: string;
      blockchain?: string;
      className?: string;
    }
    
    export function ProtocolTVLCard({ protocol, blockchain, className }: ProtocolTVLCardProps) {
      const { data: tvl, isLoading, error } = useProtocolTVL({ protocol, blockchain });
    
      if (isLoading) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 animate-pulse \${className}\`}>
            <div className="h-4 bg-zinc-700 rounded w-1/3 mb-2" />
            <div className="h-8 bg-zinc-700 rounded w-1/2" />
          </div>
        );
      }
    
      if (error || !tvl) {
        return (
          <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-red-500/30 \${className}\`}>
            <p className="text-red-400 text-sm">Failed to load TVL</p>
          </div>
        );
      }
    
      return (
        <div className={\`p-4 rounded-xl bg-zinc-800/50 border border-zinc-700/50 \${className}\`}>
          <div className="flex items-center justify-between mb-2">
            <h3 className="text-sm font-medium text-zinc-400">{tvl.protocol}</h3>
            <span className="text-xs text-zinc-500">{tvl.blockchain}</span>
          </div>
          <p className="text-2xl font-bold text-white">
            \${(tvl.tvl_usd / 1e6).toFixed(2)}M
          </p>
          <p className={\`text-sm mt-1 \${tvl.change_24h_percent >= 0 ? 'text-green-400' : 'text-red-400'}\`}>
            {tvl.change_24h_percent >= 0 ? '+' : ''}{tvl.change_24h_percent.toFixed(2)}% (24h)
          </p>
        </div>
      );
    }
    
    export default ProtocolTVLCard;
  `);
}
