import type { z } from 'zod';
import type { IPFSStorageConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof IPFSStorageConfig>;

export function generateStorageClient(config: Config): string {
  if (config.provider === 'pinata') {
    return dedent(`
      // Pinata IPFS Client
      // Generated by [N]skills
      
      const PINATA_API_KEY = process.env.PINATA_API_KEY;
      const PINATA_SECRET_KEY = process.env.PINATA_SECRET_KEY;
      const PINATA_GATEWAY = process.env.NEXT_PUBLIC_PINATA_GATEWAY ?? 'https://gateway.pinata.cloud';
      
      export interface UploadResult {
        cid: string;
        url: string;
        size: number;
      }
      
      export async function uploadFile(file: File): Promise<UploadResult> {
        const formData = new FormData();
        formData.append('file', file);
        
        const response = await fetch('https://api.pinata.cloud/pinning/pinFileToIPFS', {
          method: 'POST',
          headers: { 
            pinata_api_key: PINATA_API_KEY,
            pinata_secret_api_key: PINATA_SECRET_KEY
          },
          body: formData,
        });
        
        if (!response.ok) throw new Error('Upload failed');
        
        const data = await response.json();
        return {
          cid: data.IpfsHash,
          url: \`\${PINATA_GATEWAY}/ipfs/\${data.IpfsHash}\`,
          size: data.PinSize,
        };
      }
      
      export async function uploadJSON(json: object, name?: string): Promise<UploadResult> {
        const response = await fetch('https://api.pinata.cloud/pinning/pinJSONToIPFS', {
          method: 'POST',
          headers: {
            pinata_api_key: PINATA_API_KEY,
            pinata_secret_api_key: PINATA_SECRET_KEY,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            pinataContent: json,
            pinataMetadata: { name: name ?? 'metadata.json' },
          }),
        });
        
        if (!response.ok) throw new Error('Upload failed');
        
        const data = await response.json();
        return {
          cid: data.IpfsHash,
          url: \`\${PINATA_GATEWAY}/ipfs/\${data.IpfsHash}\`,
          size: data.PinSize,
        };
      }
      
      export function getIPFSUrl(cid: string): string {
        return \`\${PINATA_GATEWAY}/ipfs/\${cid}\`;
      }
    `);
  }

  return dedent(`
    // Web3.Storage Client
    // Generated by [N]skills
    
    import { Web3Storage } from 'web3.storage';
    
    const token = process.env.WEB3_STORAGE_TOKEN;
    const client = token ? new Web3Storage({ token }) : null;
    
    export interface UploadResult {
      cid: string;
      url: string;
      size: number;
    }
    
    export async function uploadFile(file: File): Promise<UploadResult> {
      if (!client) throw new Error('Web3.Storage not configured');
      
      const cid = await client.put([file]);
      return {
        cid,
        url: \`https://\${cid}.ipfs.w3s.link/\${file.name}\`,
        size: file.size,
      };
    }
    
    export async function uploadJSON(json: object, name = 'metadata.json'): Promise<UploadResult> {
      if (!client) throw new Error('Web3.Storage not configured');
      
      const blob = new Blob([JSON.stringify(json)], { type: 'application/json' });
      const file = new File([blob], name);
      
      const cid = await client.put([file]);
      return {
        cid,
        url: \`https://\${cid}.ipfs.w3s.link/\${name}\`,
        size: blob.size,
      };
    }
    
    export function getIPFSUrl(cid: string, filename?: string): string {
      return filename 
        ? \`https://\${cid}.ipfs.w3s.link/\${filename}\`
        : \`https://\${cid}.ipfs.w3s.link\`;
    }
  `);
}

export function generateStorageHooks(config: Config): string {
  return dedent(`
    // IPFS Storage Hooks
    // Generated by [N]skills
    
    'use client';
    
    import { useState, useCallback } from 'react';
    import { uploadFile, uploadJSON, getIPFSUrl, type UploadResult } from '@/lib/storage/storage-client';
    
    export interface UseIPFSReturn {
      upload: (file: File) => Promise<UploadResult>;
      uploadMetadata: (metadata: object, name?: string) => Promise<UploadResult>;
      isUploading: boolean;
      error: Error | null;
      lastUpload: UploadResult | null;
    }
    
    export function useIPFS(): UseIPFSReturn {
      const [isUploading, setIsUploading] = useState(false);
      const [error, setError] = useState<Error | null>(null);
      const [lastUpload, setLastUpload] = useState<UploadResult | null>(null);
      
      const upload = useCallback(async (file: File) => {
        setIsUploading(true);
        setError(null);
        
        try {
          const result = await uploadFile(file);
          setLastUpload(result);
          return result;
        } catch (err) {
          const e = err instanceof Error ? err : new Error('Upload failed');
          setError(e);
          throw e;
        } finally {
          setIsUploading(false);
        }
      }, []);
      
      const uploadMetadata = useCallback(async (metadata: object, name?: string) => {
        setIsUploading(true);
        setError(null);
        
        try {
          const result = await uploadJSON(metadata, name);
          setLastUpload(result);
          return result;
        } catch (err) {
          const e = err instanceof Error ? err : new Error('Upload failed');
          setError(e);
          throw e;
        } finally {
          setIsUploading(false);
        }
      }, []);
      
      return { upload, uploadMetadata, isUploading, error, lastUpload };
    }
    
    export { getIPFSUrl };
  `);
}

export function generateUploadComponent(config: Config): string {
  return dedent(`
    // File Upload Component
    // Generated by [N]skills
    
    'use client';
    
    import { useState, useCallback } from 'react';
    import { useIPFS } from '@/hooks/useIPFS';
    
    interface FileUploadProps {
      onUpload?: (result: { cid: string; url: string }) => void;
      accept?: string;
      className?: string;
    }
    
    export function FileUpload({ onUpload, accept, className }: FileUploadProps) {
      const { upload, isUploading, error, lastUpload } = useIPFS();
      const [dragActive, setDragActive] = useState(false);
      
      const handleFile = useCallback(async (file: File) => {
        try {
          const result = await upload(file);
          onUpload?.(result);
        } catch {
          // Error handled by hook
        }
      }, [upload, onUpload]);
      
      const handleDrop = useCallback((e: React.DragEvent) => {
        e.preventDefault();
        setDragActive(false);
        
        const file = e.dataTransfer.files[0];
        if (file) handleFile(file);
      }, [handleFile]);
      
      const handleChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        const file = e.target.files?.[0];
        if (file) handleFile(file);
      }, [handleFile]);
      
      return (
        <div className={className}>
          <div
            onDragOver={(e) => { e.preventDefault(); setDragActive(true); }}
            onDragLeave={() => setDragActive(false)}
            onDrop={handleDrop}
            className={\`border-2 border-dashed rounded-lg p-8 text-center transition-colors \${
              dragActive ? 'border-emerald-500 bg-emerald-500/10' : 'border-zinc-700'
            }\`}
          >
            <input
              type="file"
              accept={accept}
              onChange={handleChange}
              className="hidden"
              id="file-upload"
              disabled={isUploading}
            />
            <label htmlFor="file-upload" className="cursor-pointer">
              {isUploading ? (
                <p className="text-zinc-400">Uploading...</p>
              ) : (
                <>
                  <p className="text-white mb-2">Drop file here or click to upload</p>
                  <p className="text-xs text-zinc-500">Files are stored on IPFS</p>
                </>
              )}
            </label>
          </div>
          
          {error && (
            <p className="mt-2 text-sm text-red-400">{error.message}</p>
          )}
          
          {lastUpload && (
            <div className="mt-3 p-3 bg-zinc-800 rounded-md">
              <p className="text-xs text-zinc-400 mb-1">Uploaded to IPFS</p>
              <a href={lastUpload.url} target="_blank" rel="noopener noreferrer"
                 className="text-sm text-emerald-400 hover:underline break-all">
                {lastUpload.url}
              </a>
            </div>
          )}
        </div>
      );
    }
    
    export default FileUpload;
  `);
}

