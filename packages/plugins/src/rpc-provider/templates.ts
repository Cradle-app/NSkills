import type { z } from 'zod';
import type { RPCProviderConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof RPCProviderConfig>;

/**
 * Generate provider configuration
 */
export function generateProviderConfig(config: Config): string {
  return dedent(`
    // RPC Provider Configuration
    // Generated by [N]skills
    
    import { arbitrum, arbitrumSepolia } from 'viem/chains';
    
    export type ProviderName = 'alchemy' | 'quicknode' | 'infura' | 'ankr' | '1rpc' | 'public';
    
    export interface ProviderEndpoint {
      name: ProviderName;
      http: string;
      ws?: string;
      priority: number;
      rateLimit?: number; // requests per second
      requiresKey: boolean;
    }
    
    // Chain configurations
    export const CHAIN_CONFIG = {
      arbitrum: {
        id: arbitrum.id,
        name: 'Arbitrum One',
        isTestnet: false,
      },
      arbitrumSepolia: {
        id: arbitrumSepolia.id,
        name: 'Arbitrum Sepolia',
        isTestnet: true,
      },
    } as const;
    
    // Provider endpoint templates
    const PROVIDER_TEMPLATES: Record<ProviderName, {
      arbitrum: { http: string; ws?: string };
      arbitrumSepolia: { http: string; ws?: string };
      requiresKey: boolean;
      rateLimit?: number;
    }> = {
      alchemy: {
        arbitrum: {
          http: 'https://arb-mainnet.g.alchemy.com/v2/{API_KEY}',
          ws: 'wss://arb-mainnet.g.alchemy.com/v2/{API_KEY}',
        },
        arbitrumSepolia: {
          http: 'https://arb-sepolia.g.alchemy.com/v2/{API_KEY}',
          ws: 'wss://arb-sepolia.g.alchemy.com/v2/{API_KEY}',
        },
        requiresKey: true,
        rateLimit: 330, // ~330 CU/s on free tier
      },
      quicknode: {
        arbitrum: {
          http: '{ENDPOINT}',
          ws: '{ENDPOINT}'.replace('https://', 'wss://'),
        },
        arbitrumSepolia: {
          http: '{ENDPOINT}',
          ws: '{ENDPOINT}'.replace('https://', 'wss://'),
        },
        requiresKey: true,
        rateLimit: 25,
      },
      infura: {
        arbitrum: {
          http: 'https://arbitrum-mainnet.infura.io/v3/{API_KEY}',
          ws: 'wss://arbitrum-mainnet.infura.io/ws/v3/{API_KEY}',
        },
        arbitrumSepolia: {
          http: 'https://arbitrum-sepolia.infura.io/v3/{API_KEY}',
          ws: 'wss://arbitrum-sepolia.infura.io/ws/v3/{API_KEY}',
        },
        requiresKey: true,
        rateLimit: 10,
      },
      ankr: {
        arbitrum: {
          http: 'https://rpc.ankr.com/arbitrum/{API_KEY}',
          ws: 'wss://rpc.ankr.com/arbitrum/ws/{API_KEY}',
        },
        arbitrumSepolia: {
          http: 'https://rpc.ankr.com/arbitrum_sepolia/{API_KEY}',
        },
        requiresKey: false, // API key optional
        rateLimit: 30,
      },
      '1rpc': {
        arbitrum: {
          http: 'https://1rpc.io/arb',
        },
        arbitrumSepolia: {
          http: 'https://1rpc.io/arb-sepolia',
        },
        requiresKey: false,
        rateLimit: 10,
      },
      public: {
        arbitrum: {
          http: 'https://arb1.arbitrum.io/rpc',
        },
        arbitrumSepolia: {
          http: 'https://sepolia-rollup.arbitrum.io/rpc',
        },
        requiresKey: false,
        rateLimit: 5,
      },
    };
    
    /**
     * Get the RPC endpoint for a provider
     */
    export function getProviderEndpoint(
      provider: ProviderName,
      chain: 'arbitrum' | 'arbitrumSepolia' = 'arbitrum'
    ): ProviderEndpoint {
      const template = PROVIDER_TEMPLATES[provider];
      const chainConfig = template[chain];
      
      let http = chainConfig.http;
      let ws = chainConfig.ws;
      
      // Replace API key placeholders
      if (provider === 'alchemy') {
        const key = process.env.NEXT_PUBLIC_ALCHEMY_API_KEY ?? '';
        http = http.replace('{API_KEY}', key);
        ws = ws?.replace('{API_KEY}', key);
      } else if (provider === 'quicknode') {
        const endpoint = process.env.NEXT_PUBLIC_QUICKNODE_ENDPOINT ?? '';
        http = endpoint;
        ws = endpoint.replace('https://', 'wss://');
      } else if (provider === 'infura') {
        const key = process.env.NEXT_PUBLIC_INFURA_API_KEY ?? '';
        http = http.replace('{API_KEY}', key);
        ws = ws?.replace('{API_KEY}', key);
      } else if (provider === 'ankr') {
        const key = process.env.NEXT_PUBLIC_ANKR_API_KEY ?? '';
        http = key ? http.replace('{API_KEY}', key) : http.replace('/{API_KEY}', '');
        ws = key && ws ? ws.replace('{API_KEY}', key) : undefined;
      }
      
      // Priority based on configuration
      const allProviders: ProviderName[] = ['${config.primaryProvider}', ${config.fallbackProviders.map(p => `'${p}'`).join(', ')}];
      const priority = allProviders.indexOf(provider);
      
      return {
        name: provider,
        http,
        ws,
        priority: priority >= 0 ? priority : 999,
        rateLimit: template.rateLimit,
        requiresKey: template.requiresKey,
      };
    }
    
    /**
     * Get all configured provider endpoints sorted by priority
     */
    export function getAllProviderEndpoints(
      chain: 'arbitrum' | 'arbitrumSepolia' = 'arbitrum'
    ): ProviderEndpoint[] {
      const providers: ProviderName[] = ['${config.primaryProvider}', ${config.fallbackProviders.map(p => `'${p}'`).join(', ')}];
      
      return providers
        .map(p => getProviderEndpoint(p, chain))
        .filter(p => !p.requiresKey || p.http.length > 50) // Filter out unconfigured providers
        .sort((a, b) => a.priority - b.priority);
    }
    
    // Export configuration
    export const RPC_CONFIG = {
      primaryProvider: '${config.primaryProvider}' as ProviderName,
      fallbackProviders: [${config.fallbackProviders.map(p => `'${p}'`).join(', ')}] as ProviderName[],
      enableWebSocket: ${config.enableWebSocket},
      healthCheckInterval: ${config.healthCheckInterval},
      retryAttempts: ${config.retryAttempts},
      privacyMode: ${config.privacyMode},
    };
  `);
}

/**
 * Generate client factory
 */
export function generateClientFactory(config: Config): string {
  return dedent(`
    // RPC Client Factory
    // Generated by [N]skills
    
    import {
      createPublicClient,
      createWalletClient,
      http,
      webSocket,
      fallback,
      type PublicClient,
      type WalletClient,
      type Chain,
      type Transport,
    } from 'viem';
    import { arbitrum, arbitrumSepolia } from 'viem/chains';
    import {
      getAllProviderEndpoints,
      RPC_CONFIG,
      type ProviderEndpoint,
    } from './provider-config';
    
    // Cache for clients
    const clientCache = new Map<string, PublicClient>();
    
    /**
     * Create transport from provider endpoint
     */
    function createTransport(endpoint: ProviderEndpoint, useWebSocket: boolean): Transport {
      if (useWebSocket && endpoint.ws && RPC_CONFIG.enableWebSocket) {
        return webSocket(endpoint.ws, {
          reconnect: {
            attempts: RPC_CONFIG.retryAttempts,
            delay: 1000,
          },
        });
      }
      
      return http(endpoint.http, {
        retryCount: RPC_CONFIG.retryAttempts,
        retryDelay: 1000,
        timeout: 10000,
      });
    }
    
    /**
     * Create a fallback transport from all configured providers
     */
    function createFallbackTransport(
      chain: 'arbitrum' | 'arbitrumSepolia',
      useWebSocket: boolean = false
    ): Transport {
      const endpoints = getAllProviderEndpoints(chain);
      
      if (endpoints.length === 0) {
        throw new Error('No RPC providers configured');
      }
      
      if (endpoints.length === 1) {
        return createTransport(endpoints[0], useWebSocket);
      }
      
      return fallback(
        endpoints.map(e => createTransport(e, useWebSocket)),
        { rank: true }
      );
    }
    
    /**
     * Get chain configuration
     */
    function getChain(chainName: 'arbitrum' | 'arbitrumSepolia'): Chain {
      return chainName === 'arbitrum' ? arbitrum : arbitrumSepolia;
    }
    
    /**
     * Get a public client for reading chain data
     */
    export function getPublicClient(
      chainName: 'arbitrum' | 'arbitrumSepolia' = 'arbitrum',
      options?: { useWebSocket?: boolean }
    ): PublicClient {
      const cacheKey = \`\${chainName}-\${options?.useWebSocket ? 'ws' : 'http'}\`;
      
      if (clientCache.has(cacheKey)) {
        return clientCache.get(cacheKey)!;
      }
      
      const chain = getChain(chainName);
      const transport = createFallbackTransport(chainName, options?.useWebSocket);
      
      const client = createPublicClient({
        chain,
        transport,
        batch: {
          multicall: true,
        },
      });
      
      clientCache.set(cacheKey, client);
      return client;
    }
    
    /**
     * Get a wallet client for signing transactions
     */
    export function getWalletClient(
      chainName: 'arbitrum' | 'arbitrumSepolia' = 'arbitrum'
    ): WalletClient {
      const chain = getChain(chainName);
      const transport = createFallbackTransport(chainName, false);
      
      return createWalletClient({
        chain,
        transport,
      });
    }
    
    /**
     * Clear the client cache (useful when provider health changes)
     */
    export function clearClientCache(): void {
      clientCache.clear();
    }
    
    ${config.privacyMode ? `
    /**
     * Get a privacy-focused client using 1RPC
     */
    export function getPrivacyClient(
      chainName: 'arbitrum' | 'arbitrumSepolia' = 'arbitrum'
    ): PublicClient {
      const chain = getChain(chainName);
      const endpoint = chainName === 'arbitrum'
        ? 'https://1rpc.io/arb'
        : 'https://1rpc.io/arb-sepolia';
      
      return createPublicClient({
        chain,
        transport: http(endpoint),
      });
    }
    ` : ''}
  `);
}

/**
 * Generate health check utilities
 */
export function generateHealthCheck(config: Config): string {
  return dedent(`
    // RPC Provider Health Check
    // Generated by [N]skills
    
    import { createPublicClient, http, type PublicClient } from 'viem';
    import { arbitrum } from 'viem/chains';
    import {
      getAllProviderEndpoints,
      type ProviderName,
      type ProviderEndpoint,
    } from './provider-config';
    
    export interface HealthCheckResult {
      provider: ProviderName;
      healthy: boolean;
      latency: number | null;
      blockNumber: bigint | null;
      error?: string;
    }
    
    export interface ProviderHealthStatus {
      results: HealthCheckResult[];
      healthyProviders: ProviderName[];
      bestProvider: ProviderName | null;
      timestamp: number;
    }
    
    /**
     * Check health of a single provider
     */
    async function checkSingleProvider(
      endpoint: ProviderEndpoint
    ): Promise<HealthCheckResult> {
      const startTime = Date.now();
      
      try {
        const client = createPublicClient({
          chain: arbitrum,
          transport: http(endpoint.http, { timeout: 5000 }),
        });
        
        const blockNumber = await client.getBlockNumber();
        const latency = Date.now() - startTime;
        
        return {
          provider: endpoint.name,
          healthy: true,
          latency,
          blockNumber,
        };
      } catch (error) {
        return {
          provider: endpoint.name,
          healthy: false,
          latency: null,
          blockNumber: null,
          error: error instanceof Error ? error.message : 'Unknown error',
        };
      }
    }
    
    /**
     * Check health of all configured providers
     */
    export async function checkProviderHealth(): Promise<ProviderHealthStatus> {
      const endpoints = getAllProviderEndpoints('arbitrum');
      
      const results = await Promise.all(
        endpoints.map(e => checkSingleProvider(e))
      );
      
      const healthyProviders = results
        .filter(r => r.healthy)
        .sort((a, b) => (a.latency ?? Infinity) - (b.latency ?? Infinity))
        .map(r => r.provider);
      
      return {
        results,
        healthyProviders,
        bestProvider: healthyProviders[0] ?? null,
        timestamp: Date.now(),
      };
    }
    
    /**
     * Monitor provider health continuously
     */
    export function createHealthMonitor(
      onHealthUpdate: (status: ProviderHealthStatus) => void,
      interval: number = ${config.healthCheckInterval}
    ): { start: () => void; stop: () => void } {
      let timerId: NodeJS.Timeout | null = null;
      
      const check = async () => {
        const status = await checkProviderHealth();
        onHealthUpdate(status);
      };
      
      return {
        start: () => {
          check(); // Initial check
          timerId = setInterval(check, interval);
        },
        stop: () => {
          if (timerId) {
            clearInterval(timerId);
            timerId = null;
          }
        },
      };
    }
    
    // CLI support for running health checks
    if (typeof require !== 'undefined' && require.main === module) {
      checkProviderHealth().then(status => {
        console.log('Provider Health Status:');
        console.log('=======================');
        
        for (const result of status.results) {
          const statusIcon = result.healthy ? '✓' : '✗';
          const latency = result.latency ? \`\${result.latency}ms\` : 'N/A';
          console.log(\`\${statusIcon} \${result.provider}: \${latency}\`);
          if (result.error) {
            console.log(\`  Error: \${result.error}\`);
          }
        }
        
        console.log('');
        console.log(\`Best Provider: \${status.bestProvider ?? 'None available'}\`);
      });
    }
  `);
}

/**
 * Generate React hooks for provider management
 */
export function generateProviderHooks(config: Config): string {
  return dedent(`
    // RPC Provider Hooks
    // Generated by [N]skills
    
    'use client';
    
    import { useState, useEffect, useCallback, useMemo } from 'react';
    import { usePublicClient } from 'wagmi';
    import type { PublicClient } from 'viem';
    import {
      checkProviderHealth,
      createHealthMonitor,
      type ProviderHealthStatus,
    } from '@/lib/rpc/health-check';
    import {
      getPublicClient,
      clearClientCache,
    } from '@/lib/rpc/client-factory';
    import { RPC_CONFIG, type ProviderName } from '@/lib/rpc/provider-config';
    
    export interface UseProviderReturn {
      // Client
      client: PublicClient;
      
      // Health status
      healthStatus: ProviderHealthStatus | null;
      isHealthy: boolean;
      currentProvider: ProviderName | null;
      
      // Actions
      refreshHealth: () => Promise<void>;
      switchProvider: (provider: ProviderName) => void;
    }
    
    /**
     * Hook for RPC provider management with health monitoring
     */
    export function useProvider(): UseProviderReturn {
      const wagmiClient = usePublicClient();
      const [healthStatus, setHealthStatus] = useState<ProviderHealthStatus | null>(null);
      const [preferredProvider, setPreferredProvider] = useState<ProviderName | null>(null);
      
      // Get the best available client
      const client = useMemo(() => {
        if (preferredProvider) {
          // TODO: Get client for specific provider
          return getPublicClient();
        }
        return wagmiClient ?? getPublicClient();
      }, [wagmiClient, preferredProvider]);
      
      // Refresh health status
      const refreshHealth = useCallback(async () => {
        const status = await checkProviderHealth();
        setHealthStatus(status);
        
        // Clear cache if best provider changed
        if (status.bestProvider !== healthStatus?.bestProvider) {
          clearClientCache();
        }
      }, [healthStatus?.bestProvider]);
      
      // Switch to a specific provider
      const switchProvider = useCallback((provider: ProviderName) => {
        setPreferredProvider(provider);
        clearClientCache();
      }, []);
      
      // Start health monitoring
      useEffect(() => {
        const monitor = createHealthMonitor(
          setHealthStatus,
          RPC_CONFIG.healthCheckInterval
        );
        
        monitor.start();
        
        return () => {
          monitor.stop();
        };
      }, []);
      
      const isHealthy = healthStatus?.healthyProviders.length ?? 0 > 0;
      const currentProvider = preferredProvider ?? healthStatus?.bestProvider ?? RPC_CONFIG.primaryProvider;
      
      return {
        client,
        healthStatus,
        isHealthy,
        currentProvider,
        refreshHealth,
        switchProvider,
      };
    }
    
    /**
     * Hook for getting provider health status
     */
    export function useProviderHealth() {
      const [status, setStatus] = useState<ProviderHealthStatus | null>(null);
      const [isLoading, setIsLoading] = useState(true);
      
      useEffect(() => {
        checkProviderHealth()
          .then(setStatus)
          .finally(() => setIsLoading(false));
      }, []);
      
      return { status, isLoading };
    }
    
    /**
     * Hook for tracking connection quality
     */
    export function useConnectionQuality() {
      const { healthStatus } = useProvider();
      
      if (!healthStatus) {
        return { quality: 'unknown' as const, latency: null };
      }
      
      const bestLatency = healthStatus.results
        .filter(r => r.healthy)
        .map(r => r.latency)
        .filter((l): l is number => l !== null)
        .sort((a, b) => a - b)[0];
      
      let quality: 'excellent' | 'good' | 'fair' | 'poor' | 'disconnected';
      
      if (!bestLatency) {
        quality = 'disconnected';
      } else if (bestLatency < 100) {
        quality = 'excellent';
      } else if (bestLatency < 300) {
        quality = 'good';
      } else if (bestLatency < 1000) {
        quality = 'fair';
      } else {
        quality = 'poor';
      }
      
      return { quality, latency: bestLatency ?? null };
    }
  `);
}

