import type { z } from 'zod';
import type { StylusZKContractConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof StylusZKContractConfig>;

/**
 * Generate Cargo.toml for ZK Stylus contract
 */
export function generateCargoToml(config: Config): string {
  const crateName = config.contractName.toLowerCase().replace(/([A-Z])/g, '_$1').replace(/^_/, '');
  
  return dedent(`
    [package]
    name = "${crateName}"
    version = "0.1.0"
    edition = "2021"
    license = "MIT"

    [lib]
    crate-type = ["cdylib"]

    [dependencies]
    stylus-sdk = "0.5"
    alloy-primitives = "0.6"
    alloy-sol-types = "0.6"
    mini-alloc = "0.4"
    sha3 = "0.10"

    [features]
    default = []
    export-abi = ["stylus-sdk/export-abi"]

    [profile.release]
    codegen-units = 1
    strip = true
    lto = true
    panic = "abort"
    opt-level = "s"

    [dev-dependencies]
    tokio = { version = "1", features = ["full"] }
  `);
}

/**
 * Generate ZK contract code with proof verification
 */
export function generateZKContractCode(config: Config): string {
  return dedent(`
    // ${config.contractName} - Stylus ZK Contract
    // Generated by [N]skills
    // Privacy-preserving ${config.contractType.toUpperCase()} with Zero-Knowledge proof verification
    
    #![cfg_attr(not(feature = "export-abi"), no_main)]
    extern crate alloc;
    
    use stylus_sdk::{
        alloy_primitives::{Address, U256, FixedBytes},
        prelude::*,
        storage::*,
    };
    use sha3::{Keccak256, Digest};
    
    #[global_allocator]
    static ALLOC: mini_alloc::MiniAlloc = mini_alloc::MiniAlloc::INIT;
    
    sol_storage! {
        #[entrypoint]
        pub struct ${config.contractName} {
            // ERC721 storage
            owners: StorageMap<U256, StorageAddress>,
            balances: StorageMap<Address, StorageU256>,
            token_approvals: StorageMap<U256, StorageAddress>,
            next_token_id: StorageU256,
            
            // ZK proof verification
            verification_key: StorageBytes<32>,  // Groth16 verification key hash
            ${config.nullifierEnabled ? `
            // Nullifier tracking (prevents replay attacks)
            used_nullifiers: StorageMap<U256, StorageBool>,
            ` : ''}
        }
    }
    
    #[public]
    impl ${config.contractName} {
        /// Initialize the contract with verification key
        pub fn initialize(&mut self, vk_hash: FixedBytes<32>) {
            self.verification_key.set(vk_hash);
        }
        
        /// Mint a token using a ZK proof
        pub fn mint_with_proof(
            &mut self,
            proof: [U256; 8],      // Groth16 proof (A, B, C)
            public_inputs: [U256; 4],  // Public inputs to the circuit
            nullifier: U256,
        ) -> U256 {
            ${config.nullifierEnabled ? `
            // Check nullifier hasn't been used
            assert!(!self.used_nullifiers.get(nullifier), "Nullifier already used");
            ` : ''}
            
            // Verify the ZK proof
            let valid = self.verify_proof(proof, public_inputs);
            assert!(valid, "Invalid ZK proof");
            
            ${config.nullifierEnabled ? `
            // Mark nullifier as used
            self.used_nullifiers.insert(nullifier, true);
            ` : ''}
            
            // Extract user address from public inputs
            let user_address = self.extract_address_from_inputs(&public_inputs);
            
            // Mint token
            let token_id = self.next_token_id.get();
            self.next_token_id.set(token_id + U256::from(1));
            
            self.owners.insert(token_id, user_address);
            let balance = self.balances.get(user_address);
            self.balances.insert(user_address, balance + U256::from(1));
            
            token_id
        }
        
        /// Verify a Groth16 ZK proof
        pub fn verify_proof(
            &self,
            proof: [U256; 8],
            public_inputs: [U256; 4],
        ) -> bool {
            // Get verification key hash
            let vk_hash = self.verification_key.get();
            
            // In a real implementation, this would:
            // 1. Load the full verification key from storage or calldata
            // 2. Perform Groth16 pairing check
            // 3. Verify proof against public inputs
            
            // Simplified verification (replace with actual Groth16 verification)
            // For production, use a ZK verification library like arkworks
            
            // Basic checks
            if proof[0] == U256::ZERO || proof[1] == U256::ZERO {
                return false;
            }
            
            // Verify public inputs are within expected range
            for input in &public_inputs {
                if *input > U256::from(2).pow(U256::from(254)) {
                    return false;
                }
            }
            
            // TODO: Implement full Groth16 pairing verification
            // This requires elliptic curve pairing operations
            // For now, return true for testing (REPLACE IN PRODUCTION)
            true
        }
        
        /// Check if a nullifier has been used
        ${config.nullifierEnabled ? `
        pub fn is_nullifier_used(&self, nullifier: U256) -> bool {
            self.used_nullifiers.get(nullifier)
        }
        ` : ''}
        
        /// Extract user address from public inputs
        fn extract_address_from_inputs(&self, inputs: &[U256; 4]) -> Address {
            // In the circuit, user_address_hash is typically input[1]
            // This is a simplified extraction - adjust based on your circuit
            let hash = inputs[1];
            
            // Convert hash to address (take last 20 bytes)
            let hash_bytes = hash.to_be_bytes::<32>();
            let mut addr_bytes = [0u8; 20];
            addr_bytes.copy_from_slice(&hash_bytes[12..]);
            
            Address::from(addr_bytes)
        }
        
        // Standard ERC721 functions
        pub fn balance_of(&self, owner: Address) -> U256 {
            self.balances.get(owner)
        }
        
        pub fn owner_of(&self, token_id: U256) -> Address {
            let owner = self.owners.get(token_id);
            assert!(owner != Address::ZERO, "Token does not exist");
            owner
        }
        
        pub fn safe_transfer_from(&mut self, from: Address, to: Address, token_id: U256) {
            let owner = self.owners.get(token_id);
            assert!(owner == from, "Not the owner");
            
            self.owners.insert(token_id, to);
            let from_balance = self.balances.get(from);
            self.balances.insert(from, from_balance - U256::from(1));
            let to_balance = self.balances.get(to);
            self.balances.insert(to, to_balance + U256::from(1));
        }
    }
  `);
}

/**
 * Generate ZK circuit in Circom
 */
export function generateZKCircuit(config: Config): string {
  if (config.zkCircuitType === 'balance-proof') {
    return generateBalanceProofCircuit(config);
  } else if (config.zkCircuitType === 'ownership-proof') {
    return generateOwnershipProofCircuit(config);
  } else {
    return generateCustomCircuit(config);
  }
}

function generateBalanceProofCircuit(config: Config): string {
  return dedent(`
    pragma circom 2.1.0;

    include "../node_modules/circomlib/circuits/comparators.circom";
    include "../node_modules/circomlib/circuits/sha256/sha256.circom";
    include "../node_modules/circomlib/circuits/pedersen.circom";

    template ${config.contractName}BalanceProof() {
        // Private inputs (hidden from public)
        signal input actual_balance;        // User's real balance
        signal input salt;                  // Randomness for uniqueness
        
        // Public inputs (visible on-chain)
        signal input min_required_balance;  // Minimum threshold
        signal input user_address_hash;     // Hashed user address
        signal input timestamp;             // When oracle signed data
        signal input oracle_commitment;     // Oracle's commitment (hash of secret + data)
        
        // Output
        signal output nullifier;            // Prevents replay attacks
        
        // Verify balance is sufficient
        component gte = GreaterEqThan(64);
        gte.in[0] <== actual_balance;
        gte.in[1] <== min_required_balance;
        gte.out === 1;
        
        // Generate nullifier (hash of balance + salt + user address)
        component nullifier_hash = Sha256(3);
        nullifier_hash.in[0] <== actual_balance;
        nullifier_hash.in[1] <== salt;
        nullifier_hash.in[2] <== user_address_hash;
        nullifier <== nullifier_hash.out[0];
        
        // Verify oracle commitment
        // In production, this would verify the oracle signed the data correctly
        // For now, we include the commitment as a public input
    }

    component main = ${config.contractName}BalanceProof();
  `);
}

function generateOwnershipProofCircuit(config: Config): string {
  return dedent(`
    pragma circom 2.1.0;

    include "../node_modules/circomlib/circuits/comparators.circom";
    include "../node_modules/circomlib/circuits/sha256/sha256.circom";

    template ${config.contractName}OwnershipProof() {
        // Private inputs
        signal input token_ids[10];         // Array of owned token IDs (hidden)
        signal input salt;                  // Randomness
        
        // Public inputs
        signal input min_token_count;       // Minimum number of tokens required
        signal input user_address_hash;     // User's address hash
        signal input contract_address_hash; // Token contract address hash
        
        // Output
        signal output nullifier;
        
        // Count non-zero token IDs
        component count = CountNonZero(10);
        for (var i = 0; i < 10; i++) {
            count.in[i] <== token_ids[i];
        }
        
        // Verify minimum count
        component gte = GreaterEqThan(32);
        gte.in[0] <== count.out;
        gte.in[1] <== min_token_count;
        gte.out === 1;
        
        // Generate nullifier
        component nullifier_hash = Sha256(12);
        for (var i = 0; i < 10; i++) {
            nullifier_hash.in[i] <== token_ids[i];
        }
        nullifier_hash.in[10] <== salt;
        nullifier_hash.in[11] <== user_address_hash;
        nullifier <== nullifier_hash.out[0];
    }

    component main = ${config.contractName}OwnershipProof();
  `);
}

function generateCustomCircuit(config: Config): string {
  const customCode = config.circuitCustomization || '// Add your custom circuit logic here';
  
  return dedent(`
    pragma circom 2.1.0;

    include "../node_modules/circomlib/circuits/comparators.circom";
    include "../node_modules/circomlib/circuits/sha256/sha256.circom";

    template ${config.contractName}Custom() {
        // Define your custom inputs and outputs
        signal input private_input;
        signal input public_input;
        signal output result;
        
        ${customCode}
    }

    component main = ${config.contractName}Custom();
  `);
}

/**
 * Generate oracle service for balance verification
 */
export function generateOracleService(config: Config): string {
  return dedent(`
    // Oracle Service for ${config.contractName}
    // Provides secure balance verification for ZK proofs
    // Generated by [N]skills

    import Fastify from 'fastify';
    import { createPublicClient, http } from 'viem';
    import { arbitrumSepolia } from 'viem/chains';
    import { keccak256, toBytes, hexToBytes } from 'viem';
    import { hmac } from '@noble/hashes/hmac';
    import { sha256 } from '@noble/hashes/sha256';

    const fastify = Fastify({ logger: true });

    const ORACLE_SECRET = process.env.ORACLE_SECRET_KEY || '';
    if (!ORACLE_SECRET) {
      throw new Error('ORACLE_SECRET_KEY environment variable is required');
    }

    const client = createPublicClient({
      chain: arbitrumSepolia,
      transport: http(),
    });

    /**
     * Get user's ETH balance
     */
    async function getBalance(address: string): Promise<bigint> {
      const balance = await client.getBalance({ address: address as \`0x\${string}\` });
      return balance;
    }

    /**
     * Generate oracle commitment
     * Commitment = hash(secret || balance || address || timestamp)
     */
    function generateCommitment(
      balance: bigint,
      address: string,
      timestamp: number
    ): string {
      const message = \`\${ORACLE_SECRET}\${balance}\${address}\${timestamp}\`;
      const commitment = keccak256(toBytes(message));
      return commitment;
    }

    /**
     * Generate signed balance data
     */
    interface SignedBalanceData {
      balance: string;
      address: string;
      timestamp: number;
      commitment: string;
    }

    /**
     * GET /oracle/balance/:address
     * Get signed balance data for an address
     */
    fastify.get<{ Params: { address: string } }>('/oracle/balance/:address', async (request, reply) => {
      const { address } = request.params;
      const timestamp = Math.floor(Date.now() / 1000);
      
      try {
        const balance = await getBalance(address);
        const commitment = generateCommitment(balance, address, timestamp);
        
        const signedData: SignedBalanceData = {
          balance: balance.toString(),
          address,
          timestamp,
          commitment,
        };
        
        return signedData;
      } catch (error) {
        return reply.status(500).send({
          error: 'Failed to fetch balance',
          message: error instanceof Error ? error.message : 'Unknown error',
        });
      }
    });

    /**
     * POST /oracle/verify
     * Verify oracle commitment
     */
    fastify.post<{ Body: { balance: string; address: string; timestamp: number; commitment: string } }>(
      '/oracle/verify',
      async (request, reply) => {
        const { balance, address, timestamp, commitment } = request.body;
        
        const expectedCommitment = generateCommitment(BigInt(balance), address, timestamp);
        const isValid = commitment.toLowerCase() === expectedCommitment.toLowerCase();
        
        return { valid: isValid };
      }
    );

    /**
     * Health check
     */
    fastify.get('/health', async () => {
      return { status: 'ok', service: 'oracle' };
    });

    // Start server
    const start = async () => {
      try {
        const port = parseInt(process.env.ORACLE_PORT || '3003');
        await fastify.listen({ port, host: '0.0.0.0' });
        console.log(\`Oracle service running on port \${port}\`);
      } catch (err) {
        fastify.log.error(err);
        process.exit(1);
      }
    };

    start();
  `);
}

/**
 * Generate frontend ZK integration code
 */
export function generateFrontendZKIntegration(config: Config): string {
  return dedent(`
    // Frontend ZK Integration for ${config.contractName}
    // Generated by [N]skills

    import { readFileSync } from 'fs';
    import { groth16 } from 'snarkjs';
    import { createPublicClient, createWalletClient, http, parseAbi } from 'viem';
    import { privateKeyToAccount } from 'viem/accounts';
    import { arbitrumSepolia } from 'viem/chains';
    import { keccak256, toBytes } from 'viem';

    const CIRCUIT_WASM_PATH = process.env.CIRCUIT_WASM_PATH || '';
    const CIRCUIT_ZKEY_PATH = process.env.CIRCUIT_ZKEY_PATH || '';
    const ORACLE_URL = process.env.ORACLE_URL || 'http://localhost:3003';
    const CONTRACT_ADDRESS = process.env.ZK_CONTRACT_ADDRESS as \`0x\${string}\`;

    interface ZKProofInputs {
      actual_balance: string;
      salt: string;
      min_required_balance: string;
      user_address_hash: string;
      timestamp: number;
      oracle_commitment: string;
    }

    interface ZKProof {
      proof: {
        pi_a: [string, string, string];
        pi_b: [[string, string], [string, string], [string, string]];
        pi_c: [string, string, string];
      };
      publicSignals: string[];
    }

    /**
     * Get signed balance data from oracle
     */
    export async function getOracleBalance(address: string): Promise<{
      balance: string;
      timestamp: number;
      commitment: string;
    }> {
      const response = await fetch(\`\${ORACLE_URL}/oracle/balance/\${address}\`);
      if (!response.ok) {
        throw new Error('Failed to fetch oracle balance');
      }
      const data = await response.json();
      return {
        balance: data.balance,
        timestamp: data.timestamp,
        commitment: data.commitment,
      };
    }

    /**
     * Generate ZK proof
     */
    export async function generateZKProof(inputs: {
      userAddress: string;
      minRequiredBalance: string;
    }): Promise<ZKProof> {
      // Get balance from oracle
      const oracleData = await getOracleBalance(inputs.userAddress);
      
      // Hash user address
      const userAddressHash = keccak256(toBytes(inputs.userAddress));
      
      // Generate random salt
      const salt = Math.random().toString(36).substring(2, 15);
      
      // Prepare circuit inputs
      const circuitInputs: ZKProofInputs = {
        actual_balance: oracleData.balance,
        salt,
        min_required_balance: inputs.minRequiredBalance,
        user_address_hash: userAddressHash,
        timestamp: oracleData.timestamp,
        oracle_commitment: oracleData.commitment,
      };
      
      // Load circuit files
      const wasm = readFileSync(CIRCUIT_WASM_PATH);
      const zkey = readFileSync(CIRCUIT_ZKEY_PATH);
      
      // Generate proof
      const { proof, publicSignals } = await groth16.fullProve(
        circuitInputs,
        wasm,
        zkey
      );
      
      return { proof, publicSignals };
    }

    /**
     * Format proof for contract call
     */
    export function formatProofForContract(proof: ZKProof['proof']): [bigint, bigint, bigint, bigint, bigint, bigint, bigint, bigint] {
      return [
        BigInt(proof.pi_a[0]),
        BigInt(proof.pi_a[1]),
        BigInt(proof.pi_b[0][0]),
        BigInt(proof.pi_b[0][1]),
        BigInt(proof.pi_b[1][0]),
        BigInt(proof.pi_b[1][1]),
        BigInt(proof.pi_c[0]),
        BigInt(proof.pi_c[1]),
      ];
    }

    /**
     * Format public signals for contract
     */
    export function formatPublicSignals(publicSignals: string[]): [bigint, bigint, bigint, bigint] {
      return [
        BigInt(publicSignals[0]),
        BigInt(publicSignals[1]),
        BigInt(publicSignals[2]),
        BigInt(publicSignals[3]),
      ];
    }

    /**
     * Mint token with ZK proof
     */
    export async function mintWithProof(
      walletClient: ReturnType<typeof createWalletClient>,
      proof: ZKProof
    ): Promise<\`0x\${string}\`> {
      const formattedProof = formatProofForContract(proof.proof);
      const publicInputs = formatPublicSignals(proof.publicSignals);
      
      // Extract nullifier from public signals (typically the last one)
      const nullifier = BigInt(proof.publicSignals[proof.publicSignals.length - 1]);
      
      const ABI = parseAbi([
        'function mintWithProof(uint256[8] proof, uint256[4] publicInputs, uint256 nullifier) returns (uint256)',
      ]);
      
      const hash = await walletClient.writeContract({
        address: CONTRACT_ADDRESS,
        abi: ABI,
        functionName: 'mintWithProof',
        args: [formattedProof, publicInputs, nullifier],
      });
      
      return hash;
    }

    /**
     * Complete minting flow
     */
    export async function mintTokenWithZKProof(
      walletClient: ReturnType<typeof createWalletClient>,
      userAddress: string,
      minRequiredBalance: string
    ): Promise<\`0x\${string}\`> {
      // Generate proof
      const proof = await generateZKProof({ userAddress, minRequiredBalance });
      
      // Mint with proof
      const txHash = await mintWithProof(walletClient, proof);
      
      return txHash;
    }
  `);
}

