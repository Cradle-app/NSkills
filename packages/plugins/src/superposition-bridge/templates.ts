import type { z } from 'zod';
import type { SuperpositionBridgeConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof SuperpositionBridgeConfig>;

/**
 * Chain IDs for bridging
 */
const CHAIN_IDS = {
  arbitrum: 42161,
  ethereum: 1,
  optimism: 10,
  base: 8453,
  superposition: 55244,
};

/**
 * Generate bridge types
 */
export function generateBridgeTypes(config: Config): string {
  return dedent(`
    // Superposition Bridge Types
    // Generated by Cradle - https://cradle.dev

    import type { Address } from 'viem';

    export type BridgeToken = ${config.supportedTokens.map(t => `'${t}'`).join(' | ')};
    export type SourceChain = ${config.sourceChains.map(c => `'${c}'`).join(' | ')};

    export interface BridgeQuote {
      fromChainId: number;
      toChainId: number;
      fromToken: Address;
      toToken: Address;
      fromAmount: bigint;
      toAmount: bigint;
      estimatedGas: bigint;
      bridgeFee: bigint;
      route: BridgeRoute;
    }

    export interface BridgeRoute {
      provider: string;
      steps: BridgeStep[];
      estimatedTime: number; // seconds
    }

    export interface BridgeStep {
      type: 'swap' | 'bridge' | 'approve';
      tool: string;
      fromChain: number;
      toChain: number;
      fromToken: Address;
      toToken: Address;
      fromAmount: string;
      toAmount: string;
    }

    export interface BridgeTransaction {
      hash: string;
      status: 'pending' | 'completed' | 'failed';
      fromChain: number;
      toChain: number;
      amount: bigint;
      token: Address;
      timestamp: number;
    }

    export type BridgeStatus = 
      | 'idle'
      | 'fetching-quote'
      | 'approving'
      | 'bridging'
      | 'waiting-confirmation'
      | 'completed'
      | 'error';
  `);
}

/**
 * Generate bridge hook with Li.Fi integration
 */
export function generateBridgeHook(config: Config): string {
  const slippage = config.slippageTolerance;
  const supportedTokens = config.supportedTokens;
  const sourceChains = config.sourceChains;

  return dedent(`
    // Superposition Bridge Hook
    // Generated by Cradle - https://cradle.dev

    'use client';

    import { useState, useCallback } from 'react';
    import { useAccount, usePublicClient, useWalletClient } from 'wagmi';
    import type { Address } from 'viem';
    import { createLiFi, getRoutes, executeRoute } from '@lifi/sdk';
    import type { BridgeQuote, BridgeStatus, BridgeToken, SourceChain } from '../types/bridge';

    // Superposition chain ID
    const SUPERPOSITION_CHAIN_ID = 55244;

    // Source chain IDs
    const CHAIN_IDS: Record<SourceChain, number> = {
      ${sourceChains.map(c => `${c}: ${CHAIN_IDS[c as keyof typeof CHAIN_IDS]}`).join(',\n      ')},
    };

    // Token addresses per chain (example - update with actual addresses)
    const TOKEN_ADDRESSES: Record<SourceChain, Record<BridgeToken, Address>> = {
      ${sourceChains.map(chain => `${chain}: {
        ${supportedTokens.map(token => `${token}: '0x0000000000000000000000000000000000000000' as Address`).join(',\n        ')},
      }`).join(',\n      ')},
    };

    // Initialize Li.Fi SDK
    const lifi = createLiFi({
      integrator: 'cradle-superposition-bridge',
    });

    export interface UseBridgeOptions {
      onSuccess?: (txHash: string) => void;
      onError?: (error: Error) => void;
    }

    /**
     * Hook for bridging assets to Superposition
     */
    export function useSuperpositionBridge(options: UseBridgeOptions = {}) {
      const { address } = useAccount();
      const publicClient = usePublicClient();
      const { data: walletClient } = useWalletClient();

      const [status, setStatus] = useState<BridgeStatus>('idle');
      const [quote, setQuote] = useState<BridgeQuote | null>(null);
      const [error, setError] = useState<Error | null>(null);
      const [txHash, setTxHash] = useState<string | null>(null);

      /**
       * Get a bridge quote
       */
      const getQuote = useCallback(
        async (
          sourceChain: SourceChain,
          token: BridgeToken,
          amount: bigint
        ): Promise<BridgeQuote | null> => {
          if (!address) {
            setError(new Error('Wallet not connected'));
            return null;
          }

          setStatus('fetching-quote');
          setError(null);

          try {
            const fromChainId = CHAIN_IDS[sourceChain];
            const fromToken = TOKEN_ADDRESSES[sourceChain][token];

            const routes = await getRoutes({
              fromChainId,
              toChainId: SUPERPOSITION_CHAIN_ID,
              fromTokenAddress: fromToken,
              toTokenAddress: fromToken, // Same token on destination
              fromAmount: amount.toString(),
              fromAddress: address,
              toAddress: address,
              options: {
                slippage: ${slippage / 100}, // ${slippage}% slippage
                order: 'RECOMMENDED',
              },
            });

            if (!routes.routes || routes.routes.length === 0) {
              throw new Error('No routes found for this bridge');
            }

            const bestRoute = routes.routes[0];
            const bridgeQuote: BridgeQuote = {
              fromChainId,
              toChainId: SUPERPOSITION_CHAIN_ID,
              fromToken,
              toToken: fromToken,
              fromAmount: amount,
              toAmount: BigInt(bestRoute.toAmount),
              estimatedGas: BigInt(bestRoute.gasCostUSD || '0'),
              bridgeFee: BigInt(0), // Extract from route if available
              route: {
                provider: bestRoute.steps[0]?.toolDetails?.name || 'Unknown',
                steps: bestRoute.steps.map(step => ({
                  type: step.type as 'swap' | 'bridge' | 'approve',
                  tool: step.tool,
                  fromChain: step.action.fromChainId,
                  toChain: step.action.toChainId,
                  fromToken: step.action.fromToken.address as Address,
                  toToken: step.action.toToken.address as Address,
                  fromAmount: step.action.fromAmount,
                  toAmount: step.estimate.toAmount,
                })),
                estimatedTime: bestRoute.steps.reduce(
                  (acc, step) => acc + (step.estimate.executionDuration || 0),
                  0
                ),
              },
            };

            setQuote(bridgeQuote);
            setStatus('idle');
            return bridgeQuote;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Failed to get quote');
            setError(error);
            setStatus('error');
            options.onError?.(error);
            return null;
          }
        },
        [address, options]
      );

      /**
       * Execute bridge transaction
       */
      const bridge = useCallback(
        async (
          sourceChain: SourceChain,
          token: BridgeToken,
          amount: bigint
        ): Promise<string | null> => {
          if (!address || !walletClient) {
            setError(new Error('Wallet not connected'));
            return null;
          }

          try {
            // Get fresh quote
            const bridgeQuote = await getQuote(sourceChain, token, amount);
            if (!bridgeQuote) return null;

            setStatus('bridging');

            // Execute the route via Li.Fi
            const fromChainId = CHAIN_IDS[sourceChain];
            const fromToken = TOKEN_ADDRESSES[sourceChain][token];

            const routes = await getRoutes({
              fromChainId,
              toChainId: SUPERPOSITION_CHAIN_ID,
              fromTokenAddress: fromToken,
              toTokenAddress: fromToken,
              fromAmount: amount.toString(),
              fromAddress: address,
              toAddress: address,
            });

            if (!routes.routes || routes.routes.length === 0) {
              throw new Error('No routes found');
            }

            const result = await executeRoute(routes.routes[0], {
              // Signer will be obtained from wallet
            });

            setTxHash(result.transactionHash || null);
            setStatus('waiting-confirmation');

            // Wait for confirmation
            setStatus('completed');
            options.onSuccess?.(result.transactionHash || '');

            return result.transactionHash || null;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Bridge failed');
            setError(error);
            setStatus('error');
            options.onError?.(error);
            return null;
          }
        },
        [address, walletClient, getQuote, options]
      );

      /**
       * Reset bridge state
       */
      const reset = useCallback(() => {
        setStatus('idle');
        setQuote(null);
        setError(null);
        setTxHash(null);
      }, []);

      return {
        // State
        status,
        quote,
        error,
        txHash,
        isLoading: status === 'fetching-quote' || status === 'bridging' || status === 'waiting-confirmation',
        
        // Actions
        getQuote,
        bridge,
        reset,
        
        // Config
        supportedTokens: ${JSON.stringify(supportedTokens)} as const,
        sourceChains: ${JSON.stringify(sourceChains)} as const,
      };
    }
  `);
}

/**
 * Generate withdraw hook (Superposition -> other chains)
 */
export function generateWithdrawHook(config: Config): string {
  if (!config.enableWithdraw) return '';

  return dedent(`
    // Superposition Withdraw Hook
    // Generated by Cradle - https://cradle.dev

    'use client';

    import { useState, useCallback } from 'react';
    import { useAccount, useWalletClient } from 'wagmi';
    import type { Address } from 'viem';
    import { getRoutes, executeRoute } from '@lifi/sdk';
    import type { BridgeStatus, BridgeToken, SourceChain } from '../types/bridge';

    const SUPERPOSITION_CHAIN_ID = 55244;

    /**
     * Hook for withdrawing assets from Superposition
     */
    export function useSuperpositionWithdraw() {
      const { address } = useAccount();
      const { data: walletClient } = useWalletClient();

      const [status, setStatus] = useState<BridgeStatus>('idle');
      const [error, setError] = useState<Error | null>(null);
      const [txHash, setTxHash] = useState<string | null>(null);

      const withdraw = useCallback(
        async (
          destinationChain: SourceChain,
          token: BridgeToken,
          amount: bigint
        ): Promise<string | null> => {
          if (!address || !walletClient) {
            setError(new Error('Wallet not connected'));
            return null;
          }

          setStatus('bridging');
          setError(null);

          try {
            // Get routes from Superposition to destination
            const routes = await getRoutes({
              fromChainId: SUPERPOSITION_CHAIN_ID,
              toChainId: getChainId(destinationChain),
              fromTokenAddress: '0x0000000000000000000000000000000000000000', // Update with actual token
              toTokenAddress: '0x0000000000000000000000000000000000000000',
              fromAmount: amount.toString(),
              fromAddress: address,
              toAddress: address,
            });

            if (!routes.routes || routes.routes.length === 0) {
              throw new Error('No withdraw routes found');
            }

            const result = await executeRoute(routes.routes[0], {});

            setTxHash(result.transactionHash || null);
            setStatus('completed');

            return result.transactionHash || null;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Withdraw failed');
            setError(error);
            setStatus('error');
            return null;
          }
        },
        [address, walletClient]
      );

      return {
        status,
        error,
        txHash,
        withdraw,
        isLoading: status === 'bridging' || status === 'waiting-confirmation',
      };
    }

    function getChainId(chain: SourceChain): number {
      const chainIds: Record<SourceChain, number> = {
        arbitrum: 42161,
        ethereum: 1,
        optimism: 10,
        base: 8453,
      };
      return chainIds[chain];
    }
  `);
}

/**
 * Generate bridge UI component
 */
export function generateBridgeUI(config: Config): string {
  if (!config.generateUI) return '';

  return dedent(`
    // Superposition Bridge UI Component
    // Generated by Cradle - https://cradle.dev

    'use client';

    import { useState } from 'react';
    import { useSuperpositionBridge } from '../hooks/useSuperpositionBridge';
    import type { BridgeToken, SourceChain } from '../types/bridge';

    interface SuperpositionBridgeProps {
      className?: string;
    }

    export function SuperpositionBridge({ className }: SuperpositionBridgeProps) {
      const {
        status,
        quote,
        error,
        txHash,
        isLoading,
        getQuote,
        bridge,
        reset,
        supportedTokens,
        sourceChains,
      } = useSuperpositionBridge();

      const [sourceChain, setSourceChain] = useState<SourceChain>(sourceChains[0]);
      const [token, setToken] = useState<BridgeToken>(supportedTokens[0]);
      const [amount, setAmount] = useState('');

      const handleGetQuote = async () => {
        if (!amount) return;
        await getQuote(sourceChain, token, BigInt(parseFloat(amount) * 1e18));
      };

      const handleBridge = async () => {
        if (!amount) return;
        await bridge(sourceChain, token, BigInt(parseFloat(amount) * 1e18));
      };

      return (
        <div className={\`superposition-bridge \${className || ''}\`}>
          <h2 className="text-xl font-bold mb-4">Bridge to Superposition</h2>
          
          {/* Source Chain Selector */}
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">From Chain</label>
            <select
              value={sourceChain}
              onChange={(e) => setSourceChain(e.target.value as SourceChain)}
              className="w-full p-2 border rounded"
              disabled={isLoading}
            >
              {sourceChains.map((chain) => (
                <option key={chain} value={chain}>
                  {chain.charAt(0).toUpperCase() + chain.slice(1)}
                </option>
              ))}
            </select>
          </div>

          {/* Token Selector */}
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Token</label>
            <select
              value={token}
              onChange={(e) => setToken(e.target.value as BridgeToken)}
              className="w-full p-2 border rounded"
              disabled={isLoading}
            >
              {supportedTokens.map((t) => (
                <option key={t} value={t}>{t}</option>
              ))}
            </select>
          </div>

          {/* Amount Input */}
          <div className="mb-4">
            <label className="block text-sm font-medium mb-1">Amount</label>
            <input
              type="number"
              value={amount}
              onChange={(e) => setAmount(e.target.value)}
              placeholder="0.0"
              className="w-full p-2 border rounded"
              disabled={isLoading}
            />
          </div>

          {/* Quote Display */}
          {quote && (
            <div className="mb-4 p-3 bg-gray-100 rounded">
              <p className="text-sm">
                You will receive: ~{(Number(quote.toAmount) / 1e18).toFixed(6)} {token}
              </p>
              <p className="text-xs text-gray-600">
                Estimated time: {Math.ceil(quote.route.estimatedTime / 60)} min
              </p>
              <p className="text-xs text-gray-600">
                Route: {quote.route.provider}
              </p>
            </div>
          )}

          {/* Error Display */}
          {error && (
            <div className="mb-4 p-3 bg-red-100 text-red-700 rounded">
              {error.message}
            </div>
          )}

          {/* Success Display */}
          {txHash && (
            <div className="mb-4 p-3 bg-green-100 text-green-700 rounded">
              <p>Bridge initiated!</p>
              <a
                href={\`https://explorer.superposition.so/tx/\${txHash}\`}
                target="_blank"
                rel="noopener noreferrer"
                className="underline"
              >
                View on Explorer
              </a>
            </div>
          )}

          {/* Action Buttons */}
          <div className="flex gap-2">
            <button
              onClick={handleGetQuote}
              disabled={isLoading || !amount}
              className="flex-1 p-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
            >
              {status === 'fetching-quote' ? 'Getting Quote...' : 'Get Quote'}
            </button>
            <button
              onClick={handleBridge}
              disabled={isLoading || !quote}
              className="flex-1 p-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50"
            >
              {status === 'bridging' ? 'Bridging...' : 'Bridge'}
            </button>
          </div>

          {/* Status */}
          <p className="mt-2 text-sm text-gray-600 text-center">
            Status: {status}
          </p>
        </div>
      );
    }
  `);
}

/**
 * Generate bridge documentation
 */
export function generateBridgeDocs(config: Config): string {
  return dedent(`
    # Superposition Bridge Integration

    This module provides utilities for bridging assets to and from Superposition L3.

    ## Overview

    The bridge uses Li.Fi SDK to find optimal routes for cross-chain transfers.

    ### Supported Source Chains
    ${config.sourceChains.map(c => `- ${c.charAt(0).toUpperCase() + c.slice(1)}`).join('\n    ')}

    ### Supported Tokens
    ${config.supportedTokens.map(t => `- ${t}`).join('\n    ')}

    ## Usage

    ### Deposit (Bridge to Superposition)

    \`\`\`typescript
    import { useSuperpositionBridge } from './hooks/useSuperpositionBridge';

    function BridgeComponent() {
      const { getQuote, bridge, quote, status } = useSuperpositionBridge();

      const handleBridge = async () => {
        // Get a quote first
        const quote = await getQuote('arbitrum', 'ETH', BigInt(1e18));
        
        // Execute the bridge
        if (quote) {
          const txHash = await bridge('arbitrum', 'ETH', BigInt(1e18));
          console.log('Bridge tx:', txHash);
        }
      };

      return <button onClick={handleBridge}>Bridge 1 ETH</button>;
    }
    \`\`\`

    ${config.enableWithdraw ? `
    ### Withdraw (Bridge from Superposition)

    \`\`\`typescript
    import { useSuperpositionWithdraw } from './hooks/useSuperpositionWithdraw';

    function WithdrawComponent() {
      const { withdraw, status } = useSuperpositionWithdraw();

      const handleWithdraw = async () => {
        const txHash = await withdraw('arbitrum', 'ETH', BigInt(1e18));
        console.log('Withdraw tx:', txHash);
      };

      return <button onClick={handleWithdraw}>Withdraw 1 ETH</button>;
    }
    \`\`\`
    ` : ''}

    ## Configuration

    - **Slippage Tolerance**: ${config.slippageTolerance}%
    - **Bridge Provider**: ${config.bridgeProvider}

    ## Resources

    - [Li.Fi Documentation](https://docs.li.fi)
    - [Superposition Bridge](https://bridge.superposition.so)
  `);
}
