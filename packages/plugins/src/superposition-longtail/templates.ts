import type { z } from 'zod';
import type { SuperpositionLongtailConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof SuperpositionLongtailConfig>;

/**
 * Generate Longtail types
 */
export function generateLongtailTypes(config: Config): string {
  return dedent(`
    // Longtail AMM Types
    // Generated by [N]skills - https://www.nskills.xyz

    import type { Address } from 'viem';

    /**
     * Pool information
     */
    export interface LongtailPool {
      address: Address;
      token0: Address;
      token1: Address;
      fee: number;
      liquidity: bigint;
      sqrtPriceX96: bigint;
      tick: number;
      token0Symbol: string;
      token1Symbol: string;
      tvlUsd: number;
      volume24h: number;
      apr: number;
    }

    /**
     * Swap quote
     */
    export interface SwapQuote {
      tokenIn: Address;
      tokenOut: Address;
      amountIn: bigint;
      amountOut: bigint;
      priceImpact: number;
      route: SwapRoute[];
      estimatedGas: bigint;
    }

    /**
     * Swap route step
     */
    export interface SwapRoute {
      pool: Address;
      tokenIn: Address;
      tokenOut: Address;
      fee: number;
    }

    /**
     * Position information for LPs
     */
    export interface LiquidityPosition {
      tokenId: bigint;
      owner: Address;
      pool: Address;
      token0: Address;
      token1: Address;
      tickLower: number;
      tickUpper: number;
      liquidity: bigint;
      tokensOwed0: bigint;
      tokensOwed1: bigint;
      feeGrowthInside0: bigint;
      feeGrowthInside1: bigint;
    }

    /**
     * Swap status
     */
    export type SwapStatus = 
      | 'idle'
      | 'fetching-quote'
      | 'approving'
      | 'swapping'
      | 'completed'
      | 'error';

    /**
     * Token information
     */
    export interface TokenInfo {
      address: Address;
      symbol: string;
      name: string;
      decimals: number;
      logoURI?: string;
    }
  `);
}

/**
 * Generate Longtail ABIs
 */
export function generateLongtailABIs(): string {
  return dedent(`
    // Longtail AMM ABIs
    // Generated by [N]skills - https://www.nskills.xyz
    // Note: These are placeholder ABIs - update with actual Longtail contract ABIs

    export const LONGTAIL_ROUTER_ABI = [
      {
        name: 'exactInputSingle',
        type: 'function',
        stateMutability: 'payable',
        inputs: [
          {
            name: 'params',
            type: 'tuple',
            components: [
              { name: 'tokenIn', type: 'address' },
              { name: 'tokenOut', type: 'address' },
              { name: 'fee', type: 'uint24' },
              { name: 'recipient', type: 'address' },
              { name: 'deadline', type: 'uint256' },
              { name: 'amountIn', type: 'uint256' },
              { name: 'amountOutMinimum', type: 'uint256' },
              { name: 'sqrtPriceLimitX96', type: 'uint160' },
            ],
          },
        ],
        outputs: [{ name: 'amountOut', type: 'uint256' }],
      },
      {
        name: 'exactOutputSingle',
        type: 'function',
        stateMutability: 'payable',
        inputs: [
          {
            name: 'params',
            type: 'tuple',
            components: [
              { name: 'tokenIn', type: 'address' },
              { name: 'tokenOut', type: 'address' },
              { name: 'fee', type: 'uint24' },
              { name: 'recipient', type: 'address' },
              { name: 'deadline', type: 'uint256' },
              { name: 'amountOut', type: 'uint256' },
              { name: 'amountInMaximum', type: 'uint256' },
              { name: 'sqrtPriceLimitX96', type: 'uint160' },
            ],
          },
        ],
        outputs: [{ name: 'amountIn', type: 'uint256' }],
      },
    ] as const;

    export const LONGTAIL_FACTORY_ABI = [
      {
        name: 'getPool',
        type: 'function',
        stateMutability: 'view',
        inputs: [
          { name: 'tokenA', type: 'address' },
          { name: 'tokenB', type: 'address' },
          { name: 'fee', type: 'uint24' },
        ],
        outputs: [{ name: 'pool', type: 'address' }],
      },
      {
        name: 'createPool',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'tokenA', type: 'address' },
          { name: 'tokenB', type: 'address' },
          { name: 'fee', type: 'uint24' },
        ],
        outputs: [{ name: 'pool', type: 'address' }],
      },
    ] as const;

    export const LONGTAIL_POOL_ABI = [
      {
        name: 'slot0',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [
          { name: 'sqrtPriceX96', type: 'uint160' },
          { name: 'tick', type: 'int24' },
          { name: 'observationIndex', type: 'uint16' },
          { name: 'observationCardinality', type: 'uint16' },
          { name: 'observationCardinalityNext', type: 'uint16' },
          { name: 'feeProtocol', type: 'uint8' },
          { name: 'unlocked', type: 'bool' },
        ],
      },
      {
        name: 'liquidity',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'uint128' }],
      },
      {
        name: 'token0',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'address' }],
      },
      {
        name: 'token1',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'address' }],
      },
      {
        name: 'fee',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'uint24' }],
      },
    ] as const;

    export const ERC20_ABI = [
      {
        name: 'approve',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ name: '', type: 'bool' }],
      },
      {
        name: 'allowance',
        type: 'function',
        stateMutability: 'view',
        inputs: [
          { name: 'owner', type: 'address' },
          { name: 'spender', type: 'address' },
        ],
        outputs: [{ name: '', type: 'uint256' }],
      },
      {
        name: 'balanceOf',
        type: 'function',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ name: '', type: 'uint256' }],
      },
    ] as const;
  `);
}

/**
 * Generate swap hook
 */
export function generateSwapHook(config: Config): string {
  const slippage = config.defaultSlippage;

  return dedent(`
    // Longtail Swap Hook
    // Generated by [N]skills - https://www.nskills.xyz

    'use client';

    import { useState, useCallback } from 'react';
    import { useAccount, usePublicClient, useWalletClient } from 'wagmi';
    import type { Address } from 'viem';
    import { parseUnits, formatUnits } from 'viem';
    import type { SwapQuote, SwapStatus } from '../types/longtail';
    import { LONGTAIL_ROUTER_ABI, ERC20_ABI } from '../abi/longtail';
    import { getSuperpositionContracts } from '../config/superposition-constants';

    // Default slippage: ${slippage}%
    const DEFAULT_SLIPPAGE = ${slippage};

    export interface UseSwapOptions {
      slippage?: number;
      onSuccess?: (txHash: string) => void;
      onError?: (error: Error) => void;
    }

    /**
     * Hook for swapping tokens on Longtail AMM
     */
    export function useLongtailSwap(options: UseSwapOptions = {}) {
      const { address } = useAccount();
      const publicClient = usePublicClient();
      const { data: walletClient } = useWalletClient();

      const [status, setStatus] = useState<SwapStatus>('idle');
      const [quote, setQuote] = useState<SwapQuote | null>(null);
      const [error, setError] = useState<Error | null>(null);
      const [txHash, setTxHash] = useState<string | null>(null);

      const slippage = options.slippage ?? DEFAULT_SLIPPAGE;

      /**
       * Get a swap quote
       */
      const getQuote = useCallback(
        async (
          tokenIn: Address,
          tokenOut: Address,
          amountIn: bigint,
          fee: number = 3000 // 0.3% default fee tier
        ): Promise<SwapQuote | null> => {
          if (!publicClient) {
            setError(new Error('Public client not available'));
            return null;
          }

          setStatus('fetching-quote');
          setError(null);

          try {
            const contracts = getSuperpositionContracts(55244);
            
            // In production, this would call a quoter contract or API
            // For now, we'll simulate a quote
            const estimatedOutput = amountIn * BigInt(99) / BigInt(100); // ~1% fee simulation
            
            const swapQuote: SwapQuote = {
              tokenIn,
              tokenOut,
              amountIn,
              amountOut: estimatedOutput,
              priceImpact: 0.1, // Simulated
              route: [{
                pool: contracts.LONGTAIL_AMM, // Longtail AMM: 0xF3334049A3ce7e890bd4f8C6a0FBC70e38fd3746
                tokenIn,
                tokenOut,
                fee,
              }],
              estimatedGas: BigInt(200000),
            };

            setQuote(swapQuote);
            setStatus('idle');
            return swapQuote;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Failed to get quote');
            setError(error);
            setStatus('error');
            options.onError?.(error);
            return null;
          }
        },
        [publicClient, options]
      );

      /**
       * Execute a swap
       */
      const swap = useCallback(
        async (
          tokenIn: Address,
          tokenOut: Address,
          amountIn: bigint,
          fee: number = 3000
        ): Promise<string | null> => {
          if (!address || !walletClient || !publicClient) {
            setError(new Error('Wallet not connected'));
            return null;
          }

          try {
            // Get fresh quote
            const swapQuote = await getQuote(tokenIn, tokenOut, amountIn, fee);
            if (!swapQuote) return null;

            const contracts = getSuperpositionContracts(55244);

            // Check and approve if needed
            setStatus('approving');
            const allowance = await publicClient.readContract({
              address: tokenIn,
              abi: ERC20_ABI,
              functionName: 'allowance',
              args: [address, contracts.LONGTAIL_PERMIT2_ROUTER],
            });

            if (allowance < amountIn) {
              const approveHash = await walletClient.writeContract({
                address: tokenIn,
                abi: ERC20_ABI,
                functionName: 'approve',
                args: [contracts.LONGTAIL_PERMIT2_ROUTER, amountIn],
              });
              await publicClient.waitForTransactionReceipt({ hash: approveHash });
            }

            // Execute swap via Permit2 Router (0x244517Dc59943E8CdFbD424Bdb3262c5f04a1387)
            setStatus('swapping');
            const minAmountOut = swapQuote.amountOut * BigInt(100 - Math.floor(slippage * 100)) / BigInt(10000);
            const deadline = BigInt(Math.floor(Date.now() / 1000) + 1800); // 30 min

            const hash = await walletClient.writeContract({
              address: contracts.LONGTAIL_PERMIT2_ROUTER,
              abi: LONGTAIL_ROUTER_ABI,
              functionName: 'exactInputSingle',
              args: [{
                tokenIn,
                tokenOut,
                fee,
                recipient: address,
                deadline,
                amountIn,
                amountOutMinimum: minAmountOut,
                sqrtPriceLimitX96: BigInt(0),
              }],
            });

            setTxHash(hash);
            await publicClient.waitForTransactionReceipt({ hash });
            setStatus('completed');
            options.onSuccess?.(hash);

            return hash;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Swap failed');
            setError(error);
            setStatus('error');
            options.onError?.(error);
            return null;
          }
        },
        [address, walletClient, publicClient, getQuote, slippage, options]
      );

      /**
       * Reset state
       */
      const reset = useCallback(() => {
        setStatus('idle');
        setQuote(null);
        setError(null);
        setTxHash(null);
      }, []);

      return {
        status,
        quote,
        error,
        txHash,
        isLoading: status !== 'idle' && status !== 'completed' && status !== 'error',
        getQuote,
        swap,
        reset,
      };
    }
  `);
}

/**
 * Generate pool queries hook
 */
export function generatePoolHook(config: Config): string {
  if (!config.features.includes('pool-queries')) return '';

  return dedent(`
    // Longtail Pool Queries Hook
    // Generated by [N]skills - https://www.nskills.xyz

    'use client';

    import { useCallback } from 'react';
    import { usePublicClient } from 'wagmi';
    import type { Address } from 'viem';
    import type { LongtailPool } from '../types/longtail';
    import { LONGTAIL_FACTORY_ABI, LONGTAIL_POOL_ABI } from '../abi/longtail';
    import { getSuperpositionContracts } from '../config/superposition-constants';
    import { useQuery } from '@tanstack/react-query';

    /**
     * Hook for querying Longtail pool information
     */
    export function useLongtailPool(
      token0: Address,
      token1: Address,
      fee: number = 3000
    ) {
      const publicClient = usePublicClient();
      const contracts = getSuperpositionContracts(55244);

      const { data: pool, isLoading, error, refetch } = useQuery({
        queryKey: ['longtail-pool', token0, token1, fee],
        queryFn: async (): Promise<LongtailPool | null> => {
          if (!publicClient) return null;

          try {
            // Get pool address from Longtail AMM (0xF3334049A3ce7e890bd4f8C6a0FBC70e38fd3746)
            const poolAddress = await publicClient.readContract({
              address: contracts.LONGTAIL_AMM,
              abi: LONGTAIL_FACTORY_ABI,
              functionName: 'getPool',
              args: [token0, token1, fee],
            });

            if (poolAddress === '0x0000000000000000000000000000000000000000') {
              return null;
            }

            // Get pool data
            const [slot0, liquidity, poolToken0, poolToken1, poolFee] = await Promise.all([
              publicClient.readContract({
                address: poolAddress,
                abi: LONGTAIL_POOL_ABI,
                functionName: 'slot0',
              }),
              publicClient.readContract({
                address: poolAddress,
                abi: LONGTAIL_POOL_ABI,
                functionName: 'liquidity',
              }),
              publicClient.readContract({
                address: poolAddress,
                abi: LONGTAIL_POOL_ABI,
                functionName: 'token0',
              }),
              publicClient.readContract({
                address: poolAddress,
                abi: LONGTAIL_POOL_ABI,
                functionName: 'token1',
              }),
              publicClient.readContract({
                address: poolAddress,
                abi: LONGTAIL_POOL_ABI,
                functionName: 'fee',
              }),
            ]);

            return {
              address: poolAddress,
              token0: poolToken0,
              token1: poolToken1,
              fee: Number(poolFee),
              liquidity: BigInt(liquidity),
              sqrtPriceX96: slot0[0],
              tick: slot0[1],
              token0Symbol: 'TOKEN0', // Would fetch from token contract
              token1Symbol: 'TOKEN1',
              tvlUsd: 0, // Would calculate from price feed
              volume24h: 0,
              apr: 0,
            };
          } catch (err) {
            console.error('Failed to fetch pool:', err);
            return null;
          }
        },
        enabled: !!publicClient && !!token0 && !!token1,
        staleTime: 30_000, // 30 seconds
      });

      return {
        pool,
        isLoading,
        error,
        refetch,
      };
    }

    /**
     * Hook for listing all pools
     */
    export function useLongtailPools() {
      // In production, this would fetch from an indexer or subgraph
      const { data: pools, isLoading, error } = useQuery({
        queryKey: ['longtail-pools'],
        queryFn: async (): Promise<LongtailPool[]> => {
          // Placeholder - would fetch from API/subgraph
          return [];
        },
        staleTime: 60_000, // 1 minute
      });

      return {
        pools: pools ?? [],
        isLoading,
        error,
      };
    }
  `);
}

/**
 * Generate liquidity hook
 */
export function generateLiquidityHook(config: Config): string {
  if (!config.features.includes('liquidity')) return '';

  return dedent(`
    // Longtail Liquidity Hook
    // Generated by [N]skills - https://www.nskills.xyz

    'use client';

    import { useState, useCallback } from 'react';
    import { useAccount, usePublicClient, useWalletClient } from 'wagmi';
    import type { Address } from 'viem';
    import type { LiquidityPosition } from '../types/longtail';

    export interface AddLiquidityParams {
      token0: Address;
      token1: Address;
      fee: number;
      tickLower: number;
      tickUpper: number;
      amount0Desired: bigint;
      amount1Desired: bigint;
      amount0Min: bigint;
      amount1Min: bigint;
    }

    /**
     * Hook for managing liquidity on Longtail AMM
     */
    export function useLongtailLiquidity() {
      const { address } = useAccount();
      const publicClient = usePublicClient();
      const { data: walletClient } = useWalletClient();

      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<Error | null>(null);

      /**
       * Add liquidity to a pool
       */
      const addLiquidity = useCallback(
        async (params: AddLiquidityParams): Promise<string | null> => {
          if (!address || !walletClient || !publicClient) {
            setError(new Error('Wallet not connected'));
            return null;
          }

          setIsLoading(true);
          setError(null);

          try {
            // Implementation would call the NonfungiblePositionManager
            // This is a placeholder for the actual implementation
            console.log('Adding liquidity:', params);
            
            // Simulate transaction
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            setIsLoading(false);
            return '0x...'; // Would return actual tx hash
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Failed to add liquidity');
            setError(error);
            setIsLoading(false);
            return null;
          }
        },
        [address, walletClient, publicClient]
      );

      /**
       * Remove liquidity from a position
       */
      const removeLiquidity = useCallback(
        async (tokenId: bigint, liquidity: bigint): Promise<string | null> => {
          if (!address || !walletClient || !publicClient) {
            setError(new Error('Wallet not connected'));
            return null;
          }

          setIsLoading(true);
          setError(null);

          try {
            // Implementation would call decreaseLiquidity and collect
            console.log('Removing liquidity:', { tokenId, liquidity });
            
            setIsLoading(false);
            return '0x...';
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Failed to remove liquidity');
            setError(error);
            setIsLoading(false);
            return null;
          }
        },
        [address, walletClient, publicClient]
      );

      /**
       * Collect fees from a position
       */
      const collectFees = useCallback(
        async (tokenId: bigint): Promise<string | null> => {
          if (!address || !walletClient || !publicClient) {
            setError(new Error('Wallet not connected'));
            return null;
          }

          setIsLoading(true);
          setError(null);

          try {
            console.log('Collecting fees for:', tokenId);
            
            setIsLoading(false);
            return '0x...';
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Failed to collect fees');
            setError(error);
            setIsLoading(false);
            return null;
          }
        },
        [address, walletClient, publicClient]
      );

      return {
        addLiquidity,
        removeLiquidity,
        collectFees,
        isLoading,
        error,
      };
    }
  `);
}

/**
 * Generate swap UI component
 */
export function generateSwapUI(config: Config): string {
  if (!config.generateSwapUI) return '';

  return dedent(`
    // Longtail Swap UI Component
    // Generated by [N]skills - https://www.nskills.xyz

    'use client';

    import { useState } from 'react';
    import { parseUnits, formatUnits } from 'viem';
    import type { Address } from 'viem';
    import { useLongtailSwap } from '../hooks/useLongtailSwap';

    // Token list for Superposition (verified from docs.long.so)
    const TOKENS = [
      { symbol: 'ETH', address: '0x0000000000000000000000000000000000000000' as Address, decimals: 18 },
      { symbol: 'WETH', address: '0x1fB719f10b56d7a85DCD32f27f897375fB21cfdd' as Address, decimals: 18 },
      { symbol: 'USDC', address: '0x6c030c5CC283F791B26816f325b9C632d964F8A1' as Address, decimals: 6 },
      { symbol: 'ARB', address: '0xA2555701754464d32D9624149E3fDb459F3c8DE4' as Address, decimals: 18 },
    ];

    interface LongtailSwapProps {
      className?: string;
    }

    export function LongtailSwap({ className }: LongtailSwapProps) {
      const { status, quote, error, txHash, getQuote, swap, reset } = useLongtailSwap();

      const [tokenIn, setTokenIn] = useState(TOKENS[0]);
      const [tokenOut, setTokenOut] = useState(TOKENS[1]);
      const [amountIn, setAmountIn] = useState('');

      const handleGetQuote = async () => {
        if (!amountIn) return;
        const amount = parseUnits(amountIn, tokenIn.decimals);
        await getQuote(tokenIn.address, tokenOut.address, amount);
      };

      const handleSwap = async () => {
        if (!amountIn) return;
        const amount = parseUnits(amountIn, tokenIn.decimals);
        await swap(tokenIn.address, tokenOut.address, amount);
      };

      const handleSwitchTokens = () => {
        const temp = tokenIn;
        setTokenIn(tokenOut);
        setTokenOut(temp);
        setAmountIn('');
        reset();
      };

      return (
        <div className={\`longtail-swap \${className || ''}\`}>
          <h2 className="text-xl font-bold mb-4">Swap on Longtail</h2>
          
          {/* Token In */}
          <div className="mb-4 p-4 border rounded">
            <label className="block text-sm font-medium mb-2">From</label>
            <div className="flex gap-2">
              <select
                value={tokenIn.symbol}
                onChange={(e) => {
                  const token = TOKENS.find(t => t.symbol === e.target.value);
                  if (token) setTokenIn(token);
                }}
                className="p-2 border rounded"
              >
                {TOKENS.map(token => (
                  <option key={token.symbol} value={token.symbol}>
                    {token.symbol}
                  </option>
                ))}
              </select>
              <input
                type="number"
                value={amountIn}
                onChange={(e) => setAmountIn(e.target.value)}
                placeholder="0.0"
                className="flex-1 p-2 border rounded"
              />
            </div>
          </div>

          {/* Switch Button */}
          <div className="flex justify-center mb-4">
            <button
              onClick={handleSwitchTokens}
              className="p-2 border rounded-full hover:bg-gray-100"
            >
              ↕️
            </button>
          </div>

          {/* Token Out */}
          <div className="mb-4 p-4 border rounded">
            <label className="block text-sm font-medium mb-2">To</label>
            <div className="flex gap-2">
              <select
                value={tokenOut.symbol}
                onChange={(e) => {
                  const token = TOKENS.find(t => t.symbol === e.target.value);
                  if (token) setTokenOut(token);
                }}
                className="p-2 border rounded"
              >
                {TOKENS.map(token => (
                  <option key={token.symbol} value={token.symbol}>
                    {token.symbol}
                  </option>
                ))}
              </select>
              <input
                type="text"
                value={quote ? formatUnits(quote.amountOut, tokenOut.decimals) : ''}
                placeholder="0.0"
                className="flex-1 p-2 border rounded bg-gray-50"
                readOnly
              />
            </div>
          </div>

          {/* Quote Details */}
          {quote && (
            <div className="mb-4 p-3 bg-gray-100 rounded text-sm">
              <p>Price Impact: {quote.priceImpact.toFixed(2)}%</p>
              <p>Route: {quote.route.map(r => \`\${r.fee/10000}%\`).join(' → ')}</p>
            </div>
          )}

          {/* Error */}
          {error && (
            <div className="mb-4 p-3 bg-red-100 text-red-700 rounded">
              {error.message}
            </div>
          )}

          {/* Success */}
          {txHash && (
            <div className="mb-4 p-3 bg-green-100 text-green-700 rounded">
              <p>Swap successful!</p>
              <a
                href={\`https://explorer.superposition.so/tx/\${txHash}\`}
                target="_blank"
                rel="noopener noreferrer"
                className="underline"
              >
                View transaction
              </a>
            </div>
          )}

          {/* Actions */}
          <div className="flex gap-2">
            <button
              onClick={handleGetQuote}
              disabled={!amountIn || status !== 'idle'}
              className="flex-1 p-3 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
            >
              {status === 'fetching-quote' ? 'Getting Quote...' : 'Get Quote'}
            </button>
            <button
              onClick={handleSwap}
              disabled={!quote || status !== 'idle'}
              className="flex-1 p-3 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50"
            >
              {status === 'swapping' ? 'Swapping...' : 'Swap'}
            </button>
          </div>

          <p className="mt-4 text-xs text-gray-500 text-center">
            Every swap on Longtail earns yield rewards through Utility Mining
          </p>
        </div>
      );
    }
  `);
}

/**
 * Generate Longtail documentation
 */
export function generateLongtailDocs(config: Config): string {
  return dedent(`
    # Longtail AMM Integration

    This module provides utilities for interacting with Longtail, Superposition's native DEX.

    ## Overview

    Longtail is a concentrated liquidity AMM built with Arbitrum Stylus. It features:

    - **4x cheaper than Uniswap V3** - Built with Stylus for maximum gas efficiency
    - **Utility Mining rewards** - Every swap earns yield
    - **Super Asset pairs** - All pools paired with yield-bearing tokens

    ## Features Enabled

    ${config.features.map(f => `- ${f}`).join('\n    ')}

    ## Usage

    ### Swapping Tokens

    \`\`\`typescript
    import { useLongtailSwap } from './hooks/useLongtailSwap';

    function SwapComponent() {
      const { getQuote, swap, quote } = useLongtailSwap();

      const handleSwap = async () => {
        const quote = await getQuote(tokenIn, tokenOut, amount);
        if (quote) {
          await swap(tokenIn, tokenOut, amount);
        }
      };
    }
    \`\`\`

    ${config.features.includes('pool-queries') ? `
    ### Querying Pools

    \`\`\`typescript
    import { useLongtailPool } from './hooks/useLongtailPool';

    function PoolInfo() {
      const { pool, isLoading } = useLongtailPool(token0, token1, 3000);

      if (isLoading) return <p>Loading...</p>;
      if (!pool) return <p>Pool not found</p>;

      return <p>TVL: \${pool.tvlUsd}</p>;
    }
    \`\`\`
    ` : ''}

    ${config.features.includes('liquidity') ? `
    ### Providing Liquidity

    \`\`\`typescript
    import { useLongtailLiquidity } from './hooks/useLongtailLiquidity';

    function LPComponent() {
      const { addLiquidity, removeLiquidity, collectFees } = useLongtailLiquidity();

      // Add liquidity to a pool
      await addLiquidity({
        token0,
        token1,
        fee: 3000,
        tickLower: -887220,
        tickUpper: 887220,
        amount0Desired: parseUnits('100', 18),
        amount1Desired: parseUnits('100', 6),
        amount0Min: 0n,
        amount1Min: 0n,
      });
    }
    \`\`\`
    ` : ''}

    ## Resources

    - [Longtail App](https://long.so)
    - [Superposition Docs](https://docs.superposition.so)
  `);
}
