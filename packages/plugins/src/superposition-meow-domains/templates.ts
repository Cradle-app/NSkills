import type { z } from 'zod';
import type { SuperpositionMeowDomainsConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof SuperpositionMeowDomainsConfig>;

/**
 * Generate Meow Domains types
 */
export function generateMeowDomainsTypes(): string {
  return dedent(`
    // Superposition Meow Domains Types
    // Generated by [N]skills - https://www.nskills.xyz

    import type { Address } from 'viem';

    export interface DomainMetadata {
      twitter?: string;
      url?: string;
      email?: string;
      avatar?: string;
      description?: string;
    }

    export interface DomainInfo {
      name: string;
      owner: Address;
      resolver: Address;
      registrationDate: number;
      expirationDate?: number;
      metadata: DomainMetadata;
    }

    export interface DomainRegistration {
      name: string;
      duration: number; // in seconds
      metadata?: DomainMetadata;
    }

    export type DomainStatus = 'idle' | 'loading' | 'resolving' | 'registering' | 'success' | 'error';

    export interface UseMeowDomainReturn {
      status: DomainStatus;
      address: Address | null;
      domain: DomainInfo | null;
      metadata: DomainMetadata | null;
      isLoading: boolean;
      error: Error | null;
      refetch: () => Promise<void>;
    }

    export interface UseRegisterMeowDomainReturn {
      status: DomainStatus;
      error: Error | null;
      isLoading: boolean;
      txHash: string | null;
      register: (name: string, duration?: number, metadata?: DomainMetadata) => Promise<string>;
      checkAvailability: (name: string) => Promise<boolean>;
      getPrice: (name: string, duration?: number) => Promise<bigint>;
    }

    export interface UseReverseLookupReturn {
      domain: string | null;
      isLoading: boolean;
      error: Error | null;
    }
  `);
}

/**
 * Generate Meow Domains constants
 */
export function generateMeowDomainsConstants(): string {
  return dedent(`
    // Superposition Meow Domains Constants
    // Generated by [N]skills - https://www.nskills.xyz

    import type { Address } from 'viem';

    /**
     * Meow Domains contract addresses
     * Based on Punk Domains protocol
     * Source: https://github.com/fluidity-money/meow.domains/blob/main/src/abi/tlds.json
     */
    export const MEOW_DOMAINS_CONTRACTS = {
      mainnet: {
        // .meow TLD contract on Superposition mainnet (verified from meow.domains repo)
        // Source: https://github.com/fluidity-money/meow.domains/blob/main/src/abi/tlds.json
        tld: '0x4087fb91A1fBdef05761C02714335D232a2Bf3a1' as Address,
        
        // Punk Domains Resolver on Superposition
        resolver: '0xC6c17896fa051083324f2aD0Ed4555dC46D96E7f' as Address,
        
        // Registry - same as TLD for Punk Domains
        registry: '0x4087fb91A1fBdef05761C02714335D232a2Bf3a1' as Address,
      },
      testnet: {
        // TODO: Testnet contracts not yet available
        // Check https://docs.superposition.so for updates
        tld: '0x0000000000000000000000000000000000000000' as Address,
        resolver: '0x0000000000000000000000000000000000000000' as Address,
        registry: '0x0000000000000000000000000000000000000000' as Address,
      },
    } as const;

    /**
     * Meow Domains configuration
     */
    export const MEOW_DOMAINS_CONFIG = {
      // Top-level domain
      tld: '.meow',
      
      // Minimum domain name length
      minNameLength: 3,
      
      // Maximum domain name length
      maxNameLength: 50,
      
      // Default registration duration (1 year in seconds)
      defaultDuration: 365 * 24 * 60 * 60,
      
      // Supported metadata keys
      metadataKeys: ['twitter', 'url', 'email', 'avatar', 'description'],
      
      // Punk Domains integration
      punkDomainsUrl: 'https://punk.domains',
      
      // API endpoints
      apiBaseUrl: 'https://api.superposition.so',
      resolveEndpoint: '/v1/domains/resolve',
      metadataEndpoint: '/v1/domains/metadata',
    } as const;

    /**
     * Domain validation patterns
     */
    export const DOMAIN_VALIDATION = {
      // Valid characters: lowercase letters, numbers, hyphens (not at start/end)
      namePattern: /^[a-z0-9][a-z0-9-]*[a-z0-9]$|^[a-z0-9]$/,
      
      // Reserved names that cannot be registered
      reservedNames: ['admin', 'superposition', 'meow', 'official', 'support'],
    } as const;
  `);
}

/**
 * Generate Meow Domains ABIs
 */
export function generateMeowDomainsABIs(): string {
  return dedent(`
    // Superposition Meow Domains ABIs
    // Generated by [N]skills - https://www.nskills.xyz
    // Based on Punk Domains protocol

    /**
     * Punk Domains TLD ABI (for .meow)
     */
    export const PUNK_TLD_ABI = [
      // Domain resolution
      {
        inputs: [{ name: '_domainName', type: 'string' }],
        name: 'getDomainHolder',
        outputs: [{ name: '', type: 'address' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ name: '_domainName', type: 'string' }],
        name: 'getDomainData',
        outputs: [
          { name: 'holder', type: 'address' },
          { name: 'data', type: 'string' },
        ],
        stateMutability: 'view',
        type: 'function',
      },
      
      // Reverse lookup
      {
        inputs: [{ name: '_address', type: 'address' }],
        name: 'defaultNames',
        outputs: [{ name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function',
      },
      
      // Domain registration
      {
        inputs: [
          { name: '_domainName', type: 'string' },
          { name: '_domainHolder', type: 'address' },
          { name: '_referrer', type: 'address' },
        ],
        name: 'mint',
        outputs: [],
        stateMutability: 'payable',
        type: 'function',
      },
      
      // Domain price
      {
        inputs: [],
        name: 'price',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function',
      },
      
      // Update domain data (metadata)
      {
        inputs: [
          { name: '_domainName', type: 'string' },
          { name: '_data', type: 'string' },
        ],
        name: 'editData',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function',
      },
      
      // Events
      {
        anonymous: false,
        inputs: [
          { indexed: true, name: 'user', type: 'address' },
          { indexed: false, name: 'domainName', type: 'string' },
        ],
        name: 'DomainCreated',
        type: 'event',
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, name: 'user', type: 'address' },
          { indexed: false, name: 'domainName', type: 'string' },
        ],
        name: 'DataUpdated',
        type: 'event',
      },
    ] as const;
  `);
}

/**
 * Generate domain resolution hook
 */
export function generateResolverHook(config: Config): string {
  return dedent(`
    // Superposition Meow Domain Resolution Hook
    // Generated by [N]skills - https://www.nskills.xyz

    'use client';

    import { useState, useCallback, useEffect } from 'react';
    import { usePublicClient } from 'wagmi';
    import { type Address } from 'viem';
    import { MEOW_DOMAINS_CONTRACTS, MEOW_DOMAINS_CONFIG } from '../config/meow-domains-constants';
    import { PUNK_TLD_ABI } from '../config/meow-domains-abi';
    import type {
      DomainInfo,
      DomainMetadata,
      DomainStatus,
      UseMeowDomainReturn,
    } from '../types/meow-domains';

    interface UseMeowDomainOptions {
      network?: 'mainnet' | 'testnet';
      fetchMetadata?: boolean;
    }

    /**
     * Hook for resolving .meow domains to addresses
     */
    export function useMeowDomain(
      domain: string,
      options: UseMeowDomainOptions = {}
    ): UseMeowDomainReturn {
      const { network = 'mainnet', fetchMetadata = true } = options;
      const publicClient = usePublicClient();

      const [status, setStatus] = useState<DomainStatus>('idle');
      const [address, setAddress] = useState<Address | null>(null);
      const [domainInfo, setDomainInfo] = useState<DomainInfo | null>(null);
      const [metadata, setMetadata] = useState<DomainMetadata | null>(null);
      const [error, setError] = useState<Error | null>(null);

      const isLoading = status === 'loading' || status === 'resolving';
      const contracts = MEOW_DOMAINS_CONTRACTS[network];

      // Normalize domain name
      const normalizedDomain = domain
        .toLowerCase()
        .replace(MEOW_DOMAINS_CONFIG.tld, '')
        .trim();

      /**
       * Resolve domain to address
       */
      const resolve = useCallback(async () => {
        if (!normalizedDomain || !publicClient) return;

        setStatus('resolving');
        setError(null);

        try {
          // Get domain holder address
          const holder = await publicClient.readContract({
            address: contracts.tld,
            abi: PUNK_TLD_ABI,
            functionName: 'getDomainHolder',
            args: [normalizedDomain],
          }) as Address;

          if (holder === '0x0000000000000000000000000000000000000000') {
            setAddress(null);
            setDomainInfo(null);
            setMetadata(null);
            setStatus('idle');
            return;
          }

          setAddress(holder);

          ${config.features.includes('metadata') ? `
          // Fetch domain data (metadata)
          if (fetchMetadata) {
            const [, data] = await publicClient.readContract({
              address: contracts.tld,
              abi: PUNK_TLD_ABI,
              functionName: 'getDomainData',
              args: [normalizedDomain],
            }) as [Address, string];

            // Parse metadata from JSON string
            try {
              const parsedMetadata = data ? JSON.parse(data) : {};
              setMetadata(parsedMetadata);

              setDomainInfo({
                name: \`\${normalizedDomain}\${MEOW_DOMAINS_CONFIG.tld}\`,
                owner: holder,
                resolver: contracts.resolver,
                registrationDate: 0, // Not available from contract
                metadata: parsedMetadata,
              });
            } catch {
              setMetadata(null);
              setDomainInfo({
                name: \`\${normalizedDomain}\${MEOW_DOMAINS_CONFIG.tld}\`,
                owner: holder,
                resolver: contracts.resolver,
                registrationDate: 0,
                metadata: {},
              });
            }
          }
          ` : ''}

          setStatus('success');
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Failed to resolve domain');
          setError(error);
          setStatus('error');
        }
      }, [normalizedDomain, publicClient, contracts, fetchMetadata]);

      // Auto-resolve when domain changes
      useEffect(() => {
        if (normalizedDomain) {
          resolve();
        } else {
          setAddress(null);
          setDomainInfo(null);
          setMetadata(null);
          setStatus('idle');
        }
      }, [normalizedDomain, resolve]);

      return {
        status,
        address,
        domain: domainInfo,
        metadata,
        isLoading,
        error,
        refetch: resolve,
      };
    }
  `);
}

/**
 * Generate domain registration hook
 */
export function generateRegistrationHook(): string {
  return dedent(`
    // Superposition Meow Domain Registration Hook
    // Generated by [N]skills - https://www.nskills.xyz

    'use client';

    import { useState, useCallback } from 'react';
    import { useAccount, usePublicClient, useWalletClient } from 'wagmi';
    import { parseEther, type Address } from 'viem';
    import { MEOW_DOMAINS_CONTRACTS, MEOW_DOMAINS_CONFIG, DOMAIN_VALIDATION } from '../config/meow-domains-constants';
    import { PUNK_TLD_ABI } from '../config/meow-domains-abi';
    import type {
      DomainMetadata,
      DomainStatus,
      UseRegisterMeowDomainReturn,
    } from '../types/meow-domains';

    interface UseRegisterOptions {
      network?: 'mainnet' | 'testnet';
      referrer?: Address;
    }

    /**
     * Hook for registering .meow domains
     */
    export function useRegisterMeowDomain(
      options: UseRegisterOptions = {}
    ): UseRegisterMeowDomainReturn {
      const { network = 'mainnet', referrer = '0x0000000000000000000000000000000000000000' } = options;
      
      const { address } = useAccount();
      const publicClient = usePublicClient();
      const { data: walletClient } = useWalletClient();

      const [status, setStatus] = useState<DomainStatus>('idle');
      const [error, setError] = useState<Error | null>(null);
      const [txHash, setTxHash] = useState<string | null>(null);

      const isLoading = status === 'loading' || status === 'registering';
      const contracts = MEOW_DOMAINS_CONTRACTS[network];

      /**
       * Validate domain name
       */
      const validateName = (name: string): boolean => {
        const normalized = name.toLowerCase().replace(MEOW_DOMAINS_CONFIG.tld, '').trim();
        
        if (normalized.length < MEOW_DOMAINS_CONFIG.minNameLength) {
          throw new Error(\`Domain name must be at least \${MEOW_DOMAINS_CONFIG.minNameLength} characters\`);
        }
        
        if (normalized.length > MEOW_DOMAINS_CONFIG.maxNameLength) {
          throw new Error(\`Domain name must be at most \${MEOW_DOMAINS_CONFIG.maxNameLength} characters\`);
        }
        
        if (!DOMAIN_VALIDATION.namePattern.test(normalized)) {
          throw new Error('Domain name can only contain lowercase letters, numbers, and hyphens');
        }
        
        if (DOMAIN_VALIDATION.reservedNames.includes(normalized)) {
          throw new Error('This domain name is reserved');
        }
        
        return true;
      };

      /**
       * Check if domain is available
       */
      const checkAvailability = useCallback(
        async (name: string): Promise<boolean> => {
          if (!publicClient) return false;

          const normalized = name.toLowerCase().replace(MEOW_DOMAINS_CONFIG.tld, '').trim();
          
          try {
            validateName(normalized);

            const holder = await publicClient.readContract({
              address: contracts.tld,
              abi: PUNK_TLD_ABI,
              functionName: 'getDomainHolder',
              args: [normalized],
            }) as Address;

            return holder === '0x0000000000000000000000000000000000000000';
          } catch {
            return false;
          }
        },
        [publicClient, contracts.tld]
      );

      /**
       * Get domain price
       */
      const getPrice = useCallback(
        async (name: string, duration?: number): Promise<bigint> => {
          if (!publicClient) return 0n;

          try {
            const price = await publicClient.readContract({
              address: contracts.tld,
              abi: PUNK_TLD_ABI,
              functionName: 'price',
              args: [],
            }) as bigint;

            return price;
          } catch {
            return parseEther('0.001'); // Default price fallback
          }
        },
        [publicClient, contracts.tld]
      );

      /**
       * Register a domain
       */
      const register = useCallback(
        async (
          name: string,
          duration?: number,
          metadata?: DomainMetadata
        ): Promise<string> => {
          if (!address || !walletClient || !publicClient) {
            throw new Error('Wallet not connected');
          }

          const normalized = name.toLowerCase().replace(MEOW_DOMAINS_CONFIG.tld, '').trim();
          
          try {
            validateName(normalized);
          } catch (err) {
            setError(err as Error);
            setStatus('error');
            throw err;
          }

          setStatus('registering');
          setError(null);

          try {
            // Check availability
            const isAvailable = await checkAvailability(normalized);
            if (!isAvailable) {
              throw new Error('Domain is not available');
            }

            // Get price
            const price = await getPrice(normalized);

            // Register domain
            const { request } = await publicClient.simulateContract({
              address: contracts.tld,
              abi: PUNK_TLD_ABI,
              functionName: 'mint',
              args: [normalized, address, referrer as Address],
              value: price,
              account: address,
            });

            const hash = await walletClient.writeContract(request);
            setTxHash(hash);

            // Wait for confirmation
            await publicClient.waitForTransactionReceipt({ hash });

            // If metadata provided, update it
            if (metadata && Object.keys(metadata).length > 0) {
              const { request: editRequest } = await publicClient.simulateContract({
                address: contracts.tld,
                abi: PUNK_TLD_ABI,
                functionName: 'editData',
                args: [normalized, JSON.stringify(metadata)],
                account: address,
              });

              await walletClient.writeContract(editRequest);
            }

            setStatus('success');
            return hash;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Registration failed');
            setError(error);
            setStatus('error');
            throw error;
          }
        },
        [address, walletClient, publicClient, contracts.tld, referrer, checkAvailability, getPrice]
      );

      return {
        status,
        error,
        isLoading,
        txHash,
        register,
        checkAvailability,
        getPrice,
      };
    }
  `);
}

/**
 * Generate reverse lookup hook
 */
export function generateReverseLookupHook(): string {
  return dedent(`
    // Superposition Meow Domain Reverse Lookup Hook
    // Generated by [N]skills - https://www.nskills.xyz

    'use client';

    import { useState, useEffect } from 'react';
    import { usePublicClient } from 'wagmi';
    import { type Address } from 'viem';
    import { MEOW_DOMAINS_CONTRACTS, MEOW_DOMAINS_CONFIG } from '../config/meow-domains-constants';
    import { PUNK_TLD_ABI } from '../config/meow-domains-abi';
    import type { UseReverseLookupReturn } from '../types/meow-domains';

    interface UseReverseLookupOptions {
      network?: 'mainnet' | 'testnet';
    }

    /**
     * Hook for reverse lookup (address to .meow domain)
     */
    export function useMeowReverseLookup(
      address: Address | undefined,
      options: UseReverseLookupOptions = {}
    ): UseReverseLookupReturn {
      const { network = 'mainnet' } = options;
      const publicClient = usePublicClient();

      const [domain, setDomain] = useState<string | null>(null);
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<Error | null>(null);

      const contracts = MEOW_DOMAINS_CONTRACTS[network];

      useEffect(() => {
        if (!address || !publicClient) {
          setDomain(null);
          return;
        }

        const lookup = async () => {
          setIsLoading(true);
          setError(null);

          try {
            const name = await publicClient.readContract({
              address: contracts.tld,
              abi: PUNK_TLD_ABI,
              functionName: 'defaultNames',
              args: [address],
            }) as string;

            if (name && name !== '') {
              setDomain(\`\${name}\${MEOW_DOMAINS_CONFIG.tld}\`);
            } else {
              setDomain(null);
            }
          } catch (err) {
            setError(err instanceof Error ? err : new Error('Reverse lookup failed'));
            setDomain(null);
          } finally {
            setIsLoading(false);
          }
        };

        lookup();
      }, [address, publicClient, contracts.tld]);

      return {
        domain,
        isLoading,
        error,
      };
    }
  `);
}

/**
 * Generate domain display component
 */
export function generateDomainDisplay(): string {
  return dedent(`
    // Superposition Meow Domain Display Component
    // Generated by [N]skills - https://www.nskills.xyz

    'use client';

    import { useMeowDomain } from '../hooks/useMeowDomain';
    import { useMeowReverseLookup } from '../hooks/useMeowReverseLookup';
    import type { Address } from 'viem';

    interface MeowDomainDisplayProps {
      domain?: string;
      address?: Address;
      showMetadata?: boolean;
      className?: string;
    }

    /**
     * Component for displaying .meow domain information
     */
    export function MeowDomainDisplay({
      domain: domainProp,
      address: addressProp,
      showMetadata = true,
      className = '',
    }: MeowDomainDisplayProps) {
      // If address provided, do reverse lookup
      const { domain: reverseDomain } = useMeowReverseLookup(
        addressProp && !domainProp ? addressProp : undefined
      );

      const displayDomain = domainProp || reverseDomain;

      // Resolve domain
      const { address, metadata, isLoading, error } = useMeowDomain(displayDomain || '', {
        fetchMetadata: showMetadata,
      });

      if (isLoading) {
        return (
          <div className={\`meow-domain-loading \${className}\`}>
            <span className="loading-spinner" />
            <span>Resolving domain...</span>
          </div>
        );
      }

      if (error) {
        return (
          <div className={\`meow-domain-error \${className}\`}>
            <span>Failed to resolve domain</span>
          </div>
        );
      }

      if (!displayDomain && !address) {
        return null;
      }

      return (
        <div className={\`meow-domain-display \${className}\`}>
          <div className="domain-name">
            <span className="domain-label">üê±</span>
            <span className="domain-text">{displayDomain}</span>
          </div>

          {address && (
            <div className="domain-address">
              <span className="address-label">Address:</span>
              <span className="address-text" title={address}>
                {address.slice(0, 6)}...{address.slice(-4)}
              </span>
            </div>
          )}

          {showMetadata && metadata && (
            <div className="domain-metadata">
              {metadata.twitter && (
                <a
                  href={\`https://twitter.com/\${metadata.twitter.replace('@', '')}\`}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="metadata-item"
                >
                  @{metadata.twitter.replace('@', '')}
                </a>
              )}
              {metadata.url && (
                <a
                  href={metadata.url}
                  target="_blank"
                  rel="noopener noreferrer"
                  className="metadata-item"
                >
                  {metadata.url}
                </a>
              )}
              {metadata.description && (
                <p className="metadata-description">{metadata.description}</p>
              )}
            </div>
          )}
        </div>
      );
    }

    export default MeowDomainDisplay;
  `);
}

/**
 * Generate documentation
 */
export function generateMeowDomainsDocs(config: Config): string {
  return dedent(`
    # Meow Domains (.meow)

    Web3 identity layer with .meow domain registration and resolution on Superposition.

    ## Overview

    Meow Domains are Superposition's native Web3 naming service, built on the Punk Domains protocol. They provide:

    - **Human-readable addresses**: Replace long hex addresses with memorable names
    - **Metadata storage**: Attach social profiles, websites, and more
    - **On-chain resolution**: Fully decentralized name resolution

    ## Usage

    ### Resolve a Domain

    \`\`\`typescript
    import { useMeowDomain } from './hooks/useMeowDomain';

    function ProfileCard({ domain }) {
      const { address, metadata, isLoading } = useMeowDomain(domain);

      if (isLoading) return <p>Loading...</p>;
      if (!address) return <p>Domain not found</p>;

      return (
        <div>
          <p>Address: {address}</p>
          {metadata?.twitter && <p>Twitter: @{metadata.twitter}</p>}
        </div>
      );
    }
    \`\`\`

    ${config.features.includes('reverse-lookup') ? `
    ### Reverse Lookup (Address to Domain)

    \`\`\`typescript
    import { useMeowReverseLookup } from './hooks/useMeowReverseLookup';

    function AddressDisplay({ address }) {
      const { domain, isLoading } = useMeowReverseLookup(address);

      return (
        <span>
          {domain || \`\${address.slice(0, 6)}...\${address.slice(-4)}\`}
        </span>
      );
    }
    \`\`\`
    ` : ''}

    ${config.features.includes('register') ? `
    ### Register a Domain

    \`\`\`typescript
    import { useRegisterMeowDomain } from './hooks/useRegisterMeowDomain';

    function RegisterDomain() {
      const { register, checkAvailability, getPrice, isLoading } = useRegisterMeowDomain();

      const handleRegister = async (name) => {
        const available = await checkAvailability(name);
        if (!available) {
          alert('Domain not available');
          return;
        }

        const price = await getPrice(name);
        console.log('Price:', formatEther(price), 'ETH');

        const txHash = await register(name, undefined, {
          twitter: 'myhandle',
          url: 'https://mysite.com',
        });
        console.log('Registered!', txHash);
      };

      return (
        <button onClick={() => handleRegister('myname')} disabled={isLoading}>
          Register myname.meow
        </button>
      );
    }
    \`\`\`
    ` : ''}

    ### Use the Display Component

    \`\`\`tsx
    import { MeowDomainDisplay } from './components/MeowDomainDisplay';

    function App() {
      return (
        <>
          {/* Resolve domain */}
          <MeowDomainDisplay domain="vitalik.meow" showMetadata />

          {/* Reverse lookup from address */}
          <MeowDomainDisplay address="0x..." />
        </>
      );
    }
    \`\`\`

    ## Domain Rules

    - **Length**: 3-50 characters
    - **Characters**: Lowercase letters, numbers, hyphens
    - **No hyphens** at start or end
    - Some names are reserved

    ## Metadata Fields

    ${config.supportedMetadata.map((m) => `- \`${m}\``).join('\n')}

    ## Resources

    - [Punk Domains Protocol](https://docs.punk.domains)
    - [Superposition Documentation](https://docs.superposition.so)
  `);
}
