import type { z } from 'zod';
import type { SuperpositionSuperAssetsConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof SuperpositionSuperAssetsConfig>;

/**
 * Generate Super Assets types
 */
export function generateSuperAssetsTypes(config: Config): string {
  return dedent(`
    // Super Assets Types
    // Generated by Cradle - https://cradle.dev

    import type { Address } from 'viem';

    /**
     * Supported Super Assets
     */
    export type SuperAssetSymbol = 'sUSDC' | 'sETH' | 'sWETH';

    /**
     * Super Asset information
     */
    export interface SuperAsset {
      symbol: SuperAssetSymbol;
      name: string;
      address: Address;
      underlyingAddress: Address;
      underlyingSymbol: string;
      decimals: number;
      apy: number; // Current APY percentage
      totalSupply: bigint;
      exchangeRate: bigint; // Rate of Super Asset to underlying
    }

    /**
     * User's Super Asset balance
     */
    export interface SuperAssetBalance {
      asset: SuperAssetSymbol;
      balance: bigint;
      underlyingValue: bigint;
      pendingYield: bigint;
      totalYieldEarned: bigint;
    }

    /**
     * Yield tracking data
     */
    export interface YieldData {
      asset: SuperAssetSymbol;
      currentApy: number;
      totalYieldEarned: bigint;
      pendingYield: bigint;
      lastClaimTimestamp: number;
      yieldHistory: YieldHistoryEntry[];
    }

    /**
     * Historical yield entry
     */
    export interface YieldHistoryEntry {
      timestamp: number;
      amount: bigint;
      txHash: string;
    }

    /**
     * Wrap/unwrap operation status
     */
    export type WrapStatus =
      | 'idle'
      | 'approving'
      | 'wrapping'
      | 'unwrapping'
      | 'completed'
      | 'error';
  `);
}

/**
 * Generate Super Assets ABIs
 */
export function generateSuperAssetsABIs(): string {
  return dedent(`
    // Super Assets ABIs
    // Generated by Cradle - https://cradle.dev
    // Note: These are placeholder ABIs - update with actual Super Asset contract ABIs

    export const SUPER_ASSET_ABI = [
      // ERC20 standard functions
      {
        name: 'balanceOf',
        type: 'function',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ name: '', type: 'uint256' }],
      },
      {
        name: 'totalSupply',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'uint256' }],
      },
      {
        name: 'decimals',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'uint8' }],
      },
      {
        name: 'symbol',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'string' }],
      },
      {
        name: 'name',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'string' }],
      },
      {
        name: 'approve',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ name: '', type: 'bool' }],
      },
      {
        name: 'transfer',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'to', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ name: '', type: 'bool' }],
      },
      // Super Asset specific functions
      {
        name: 'wrap',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ name: 'amount', type: 'uint256' }],
        outputs: [{ name: 'superAmount', type: 'uint256' }],
      },
      {
        name: 'unwrap',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [{ name: 'superAmount', type: 'uint256' }],
        outputs: [{ name: 'underlyingAmount', type: 'uint256' }],
      },
      {
        name: 'exchangeRate',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'uint256' }],
      },
      {
        name: 'underlying',
        type: 'function',
        stateMutability: 'view',
        inputs: [],
        outputs: [{ name: '', type: 'address' }],
      },
      {
        name: 'pendingYield',
        type: 'function',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ name: '', type: 'uint256' }],
      },
      {
        name: 'claimYield',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [],
        outputs: [{ name: 'yieldAmount', type: 'uint256' }],
      },
    ] as const;

    export const ERC20_ABI = [
      {
        name: 'approve',
        type: 'function',
        stateMutability: 'nonpayable',
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' },
        ],
        outputs: [{ name: '', type: 'bool' }],
      },
      {
        name: 'allowance',
        type: 'function',
        stateMutability: 'view',
        inputs: [
          { name: 'owner', type: 'address' },
          { name: 'spender', type: 'address' },
        ],
        outputs: [{ name: '', type: 'uint256' }],
      },
      {
        name: 'balanceOf',
        type: 'function',
        stateMutability: 'view',
        inputs: [{ name: 'account', type: 'address' }],
        outputs: [{ name: '', type: 'uint256' }],
      },
    ] as const;
  `);
}

/**
 * Generate Super Asset hook
 */
export function generateSuperAssetHook(config: Config): string {
  return dedent(`
    // Super Asset Hook
    // Generated by Cradle - https://cradle.dev

    'use client';

    import { useState, useCallback } from 'react';
    import { useAccount, usePublicClient, useWalletClient } from 'wagmi';
    import type { Address } from 'viem';
    import type { SuperAssetSymbol, WrapStatus } from '../types/super-assets';
    import { SUPER_ASSET_ABI, ERC20_ABI } from '../abi/super-assets';
    import { getSuperAssetAddress, getUnderlyingAddress } from '../config/super-assets-config';

    export interface UseSuperAssetOptions {
      onSuccess?: (txHash: string) => void;
      onError?: (error: Error) => void;
    }

    /**
     * Hook for interacting with a Super Asset
     */
    export function useSuperAsset(
      asset: SuperAssetSymbol,
      options: UseSuperAssetOptions = {}
    ) {
      const { address } = useAccount();
      const publicClient = usePublicClient();
      const { data: walletClient } = useWalletClient();

      const [status, setStatus] = useState<WrapStatus>('idle');
      const [error, setError] = useState<Error | null>(null);
      const [txHash, setTxHash] = useState<string | null>(null);

      const superAssetAddress = getSuperAssetAddress(asset);
      const underlyingAddress = getUnderlyingAddress(asset);

      /**
       * Wrap underlying token to Super Asset
       */
      const wrap = useCallback(
        async (amount: bigint): Promise<string | null> => {
          if (!address || !walletClient || !publicClient) {
            setError(new Error('Wallet not connected'));
            return null;
          }

          setStatus('approving');
          setError(null);

          try {
            // Check and approve underlying token
            const allowance = await publicClient.readContract({
              address: underlyingAddress,
              abi: ERC20_ABI,
              functionName: 'allowance',
              args: [address, superAssetAddress],
            });

            if (allowance < amount) {
              const approveHash = await walletClient.writeContract({
                address: underlyingAddress,
                abi: ERC20_ABI,
                functionName: 'approve',
                args: [superAssetAddress, amount],
              });
              await publicClient.waitForTransactionReceipt({ hash: approveHash });
            }

            // Wrap tokens
            setStatus('wrapping');
            const hash = await walletClient.writeContract({
              address: superAssetAddress,
              abi: SUPER_ASSET_ABI,
              functionName: 'wrap',
              args: [amount],
            });

            setTxHash(hash);
            await publicClient.waitForTransactionReceipt({ hash });
            setStatus('completed');
            options.onSuccess?.(hash);

            return hash;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Wrap failed');
            setError(error);
            setStatus('error');
            options.onError?.(error);
            return null;
          }
        },
        [address, walletClient, publicClient, superAssetAddress, underlyingAddress, options]
      );

      /**
       * Unwrap Super Asset to underlying token
       */
      const unwrap = useCallback(
        async (amount: bigint): Promise<string | null> => {
          if (!address || !walletClient || !publicClient) {
            setError(new Error('Wallet not connected'));
            return null;
          }

          setStatus('unwrapping');
          setError(null);

          try {
            const hash = await walletClient.writeContract({
              address: superAssetAddress,
              abi: SUPER_ASSET_ABI,
              functionName: 'unwrap',
              args: [amount],
            });

            setTxHash(hash);
            await publicClient.waitForTransactionReceipt({ hash });
            setStatus('completed');
            options.onSuccess?.(hash);

            return hash;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Unwrap failed');
            setError(error);
            setStatus('error');
            options.onError?.(error);
            return null;
          }
        },
        [address, walletClient, publicClient, superAssetAddress, options]
      );

      /**
       * Reset state
       */
      const reset = useCallback(() => {
        setStatus('idle');
        setError(null);
        setTxHash(null);
      }, []);

      return {
        status,
        error,
        txHash,
        isLoading: status !== 'idle' && status !== 'completed' && status !== 'error',
        wrap,
        unwrap,
        reset,
        superAssetAddress,
        underlyingAddress,
      };
    }
  `);
}

/**
 * Generate yield tracking hook
 */
export function generateYieldTrackingHook(config: Config): string {
  if (!config.generateYieldTracking) return '';

  return dedent(`
    // Super Asset Yield Tracking Hook
    // Generated by Cradle - https://cradle.dev

    'use client';

    import { useCallback } from 'react';
    import { useAccount, usePublicClient, useWalletClient } from 'wagmi';
    import { useQuery } from '@tanstack/react-query';
    import type { SuperAssetSymbol, YieldData } from '../types/super-assets';
    import { SUPER_ASSET_ABI } from '../abi/super-assets';
    import { getSuperAssetAddress } from '../config/super-assets-config';

    /**
     * Hook for tracking yield on a Super Asset
     */
    export function useSuperAssetYield(asset: SuperAssetSymbol) {
      const { address } = useAccount();
      const publicClient = usePublicClient();
      const { data: walletClient } = useWalletClient();

      const superAssetAddress = getSuperAssetAddress(asset);

      const { data: yieldData, isLoading, error, refetch } = useQuery({
        queryKey: ['super-asset-yield', asset, address],
        queryFn: async (): Promise<YieldData | null> => {
          if (!address || !publicClient) return null;

          try {
            const pendingYield = await publicClient.readContract({
              address: superAssetAddress,
              abi: SUPER_ASSET_ABI,
              functionName: 'pendingYield',
              args: [address],
            });

            // In production, would fetch historical data from an indexer
            return {
              asset,
              currentApy: 5.5, // Would fetch from API
              totalYieldEarned: BigInt(0), // Would calculate from history
              pendingYield: BigInt(pendingYield),
              lastClaimTimestamp: 0,
              yieldHistory: [],
            };
          } catch (err) {
            console.error('Failed to fetch yield data:', err);
            return null;
          }
        },
        enabled: !!address && !!publicClient,
        refetchInterval: 30_000, // Refetch every 30 seconds
      });

      /**
       * Claim pending yield
       */
      const claimYield = useCallback(async (): Promise<string | null> => {
        if (!address || !walletClient || !publicClient) return null;

        try {
          const hash = await walletClient.writeContract({
            address: superAssetAddress,
            abi: SUPER_ASSET_ABI,
            functionName: 'claimYield',
            args: [],
          });

          await publicClient.waitForTransactionReceipt({ hash });
          refetch();
          return hash;
        } catch (err) {
          console.error('Failed to claim yield:', err);
          return null;
        }
      }, [address, walletClient, publicClient, superAssetAddress, refetch]);

      return {
        yieldData,
        pendingYield: yieldData?.pendingYield ?? BigInt(0),
        currentApy: yieldData?.currentApy ?? 0,
        isLoading,
        error,
        claimYield,
        refetch,
      };
    }

    /**
     * Hook for tracking yield across all Super Assets
     */
    export function useAllSuperAssetsYield() {
      const { address } = useAccount();
      const publicClient = usePublicClient();

      const { data: yields, isLoading, error, refetch } = useQuery({
        queryKey: ['all-super-assets-yield', address],
        queryFn: async () => {
          if (!address || !publicClient) return [];

          // Would fetch yield data for all Super Assets
          return [];
        },
        enabled: !!address && !!publicClient,
        refetchInterval: 60_000,
      });

      const totalPendingYield = yields?.reduce(
        (sum, y) => sum + (y.pendingYield ?? BigInt(0)),
        BigInt(0)
      ) ?? BigInt(0);

      return {
        yields: yields ?? [],
        totalPendingYield,
        isLoading,
        error,
        refetch,
      };
    }
  `);
}

/**
 * Generate balance display hook
 */
export function generateBalanceHook(config: Config): string {
  if (!config.generateBalanceDisplay) return '';

  return dedent(`
    // Super Asset Balance Hook
    // Generated by Cradle - https://cradle.dev

    'use client';

    import { useAccount, usePublicClient } from 'wagmi';
    import { useQuery } from '@tanstack/react-query';
    import type { SuperAssetSymbol, SuperAssetBalance } from '../types/super-assets';
    import { SUPER_ASSET_ABI } from '../abi/super-assets';
    import { getSuperAssetAddress, SUPER_ASSETS } from '../config/super-assets-config';

    /**
     * Hook for getting Super Asset balance
     */
    export function useSuperAssetBalance(asset: SuperAssetSymbol) {
      const { address } = useAccount();
      const publicClient = usePublicClient();

      const superAssetAddress = getSuperAssetAddress(asset);

      const { data: balance, isLoading, error, refetch } = useQuery({
        queryKey: ['super-asset-balance', asset, address],
        queryFn: async (): Promise<SuperAssetBalance | null> => {
          if (!address || !publicClient) return null;

          try {
            const [rawBalance, exchangeRate, pendingYield] = await Promise.all([
              publicClient.readContract({
                address: superAssetAddress,
                abi: SUPER_ASSET_ABI,
                functionName: 'balanceOf',
                args: [address],
              }),
              publicClient.readContract({
                address: superAssetAddress,
                abi: SUPER_ASSET_ABI,
                functionName: 'exchangeRate',
              }),
              publicClient.readContract({
                address: superAssetAddress,
                abi: SUPER_ASSET_ABI,
                functionName: 'pendingYield',
                args: [address],
              }),
            ]);

            const underlyingValue = (BigInt(rawBalance) * BigInt(exchangeRate)) / BigInt(1e18);

            return {
              asset,
              balance: BigInt(rawBalance),
              underlyingValue,
              pendingYield: BigInt(pendingYield),
              totalYieldEarned: BigInt(0), // Would fetch from history
            };
          } catch (err) {
            console.error('Failed to fetch balance:', err);
            return null;
          }
        },
        enabled: !!address && !!publicClient,
        refetchInterval: 15_000,
      });

      return {
        balance: balance?.balance ?? BigInt(0),
        underlyingValue: balance?.underlyingValue ?? BigInt(0),
        pendingYield: balance?.pendingYield ?? BigInt(0),
        isLoading,
        error,
        refetch,
      };
    }

    /**
     * Hook for getting all Super Asset balances
     */
    export function useAllSuperAssetBalances() {
      const { address } = useAccount();
      const publicClient = usePublicClient();

      const { data: balances, isLoading, error, refetch } = useQuery({
        queryKey: ['all-super-asset-balances', address],
        queryFn: async (): Promise<SuperAssetBalance[]> => {
          if (!address || !publicClient) return [];

          const results = await Promise.all(
            SUPER_ASSETS.map(async (asset) => {
              try {
                const [rawBalance, exchangeRate, pendingYield] = await Promise.all([
                  publicClient.readContract({
                    address: asset.address,
                    abi: SUPER_ASSET_ABI,
                    functionName: 'balanceOf',
                    args: [address],
                  }),
                  publicClient.readContract({
                    address: asset.address,
                    abi: SUPER_ASSET_ABI,
                    functionName: 'exchangeRate',
                  }),
                  publicClient.readContract({
                    address: asset.address,
                    abi: SUPER_ASSET_ABI,
                    functionName: 'pendingYield',
                    args: [address],
                  }),
                ]);

                return {
                  asset: asset.symbol as SuperAssetSymbol,
                  balance: BigInt(rawBalance),
                  underlyingValue: (BigInt(rawBalance) * BigInt(exchangeRate)) / BigInt(1e18),
                  pendingYield: BigInt(pendingYield),
                  totalYieldEarned: BigInt(0),
                };
              } catch {
                return null;
              }
            })
          );

          return results.filter((r): r is SuperAssetBalance => r !== null);
        },
        enabled: !!address && !!publicClient,
        refetchInterval: 30_000,
      });

      return {
        balances: balances ?? [],
        isLoading,
        error,
        refetch,
      };
    }
  `);
}

/**
 * Generate Super Assets config
 */
export function generateSuperAssetsConfig(config: Config): string {
  return dedent(`
    // Super Assets Configuration
    // Generated by Cradle - https://cradle.dev

    import type { Address } from 'viem';
    import type { SuperAssetSymbol, SuperAsset } from '../types/super-assets';

    /**
     * Super Asset addresses on Superposition mainnet
     * 
     * NOTE: Super Asset wrapping contract addresses are not yet publicly documented.
     * Super Assets are yield-bearing wrapped tokens that earn rewards on every transaction.
     * 
     * For updates, check:
     * - https://docs.superposition.so/superposition-mainnet/super-layer/super-assets
     * - https://long.so (Longtail uses Super Assets for trading pairs)
     * 
     * The underlying token addresses are verified from docs.long.so:
     * - USDC: 0x6c030c5CC283F791B26816f325b9C632d964F8A1
     * - WETH: 0x1fB719f10b56d7a85DCD32f27f897375fB21cfdd
     */
    export const SUPER_ASSETS: SuperAsset[] = [
      {
        symbol: 'sUSDC',
        name: 'Super USDC',
        // TODO: Super USDC wrapper contract - check Superposition docs for verified address
        address: '0x0000000000000000000000000000000000000000' as Address,
        // Underlying USDC address (verified from docs.long.so)
        underlyingAddress: '0x6c030c5CC283F791B26816f325b9C632d964F8A1' as Address,
        underlyingSymbol: 'USDC',
        decimals: 6,
        apy: 5.5,
        totalSupply: BigInt(0),
        exchangeRate: BigInt(1e18),
      },
      {
        symbol: 'sETH',
        name: 'Super ETH',
        // TODO: Super ETH wrapper contract - check Superposition docs for verified address
        address: '0x0000000000000000000000000000000000000000' as Address,
        // Underlying is native ETH (zero address for native)
        underlyingAddress: '0x0000000000000000000000000000000000000000' as Address,
        underlyingSymbol: 'ETH',
        decimals: 18,
        apy: 4.2,
        totalSupply: BigInt(0),
        exchangeRate: BigInt(1e18),
      },
      {
        symbol: 'sWETH',
        name: 'Super WETH',
        // TODO: Super WETH wrapper contract - check Superposition docs for verified address
        address: '0x0000000000000000000000000000000000000000' as Address,
        // Underlying WETH address (verified from docs.long.so)
        underlyingAddress: '0x1fB719f10b56d7a85DCD32f27f897375fB21cfdd' as Address,
        underlyingSymbol: 'WETH',
        decimals: 18,
        apy: 4.2,
        totalSupply: BigInt(0),
        exchangeRate: BigInt(1e18),
      },
    ];

    /**
     * Get Super Asset address by symbol
     */
    export function getSuperAssetAddress(symbol: SuperAssetSymbol): Address {
      const asset = SUPER_ASSETS.find(a => a.symbol === symbol);
      if (!asset) throw new Error(\`Unknown Super Asset: \${symbol}\`);
      return asset.address;
    }

    /**
     * Get underlying token address for a Super Asset
     */
    export function getUnderlyingAddress(symbol: SuperAssetSymbol): Address {
      const asset = SUPER_ASSETS.find(a => a.symbol === symbol);
      if (!asset) throw new Error(\`Unknown Super Asset: \${symbol}\`);
      return asset.underlyingAddress;
    }

    /**
     * Get Super Asset info by symbol
     */
    export function getSuperAssetInfo(symbol: SuperAssetSymbol): SuperAsset {
      const asset = SUPER_ASSETS.find(a => a.symbol === symbol);
      if (!asset) throw new Error(\`Unknown Super Asset: \${symbol}\`);
      return asset;
    }

    /**
     * Check if an address is a Super Asset
     */
    export function isSuperAsset(address: Address): boolean {
      return SUPER_ASSETS.some(a => a.address.toLowerCase() === address.toLowerCase());
    }
  `);
}

/**
 * Generate Super Assets balance display UI
 */
export function generateBalanceUI(config: Config): string {
  if (!config.generateBalanceDisplay) return '';

  return dedent(`
    // Super Assets Balance Display Component
    // Generated by Cradle - https://cradle.dev

    'use client';

    import { formatUnits } from 'viem';
    import { useAllSuperAssetBalances } from '../hooks/useSuperAssetBalance';
    import { SUPER_ASSETS } from '../config/super-assets-config';

    interface SuperAssetBalanceDisplayProps {
      className?: string;
    }

    export function SuperAssetBalanceDisplay({ className }: SuperAssetBalanceDisplayProps) {
      const { balances, isLoading, error } = useAllSuperAssetBalances();

      if (isLoading) {
        return (
          <div className={\`super-asset-balances \${className || ''}\`}>
            <p className="text-gray-500">Loading balances...</p>
          </div>
        );
      }

      if (error) {
        return (
          <div className={\`super-asset-balances \${className || ''}\`}>
            <p className="text-red-500">Failed to load balances</p>
          </div>
        );
      }

      return (
        <div className={\`super-asset-balances \${className || ''}\`}>
          <h3 className="text-lg font-semibold mb-4">Super Assets</h3>
          
          <div className="space-y-3">
            {SUPER_ASSETS.map((asset) => {
              const balance = balances.find(b => b.asset === asset.symbol);
              const displayBalance = balance 
                ? formatUnits(balance.balance, asset.decimals)
                : '0';
              const displayYield = balance
                ? formatUnits(balance.pendingYield, asset.decimals)
                : '0';

              return (
                <div
                  key={asset.symbol}
                  className="flex items-center justify-between p-3 border rounded-lg"
                >
                  <div>
                    <p className="font-medium">{asset.symbol}</p>
                    <p className="text-sm text-gray-500">{asset.name}</p>
                  </div>
                  <div className="text-right">
                    <p className="font-mono">{parseFloat(displayBalance).toFixed(4)}</p>
                    {balance && balance.pendingYield > 0 && (
                      <p className="text-sm text-green-600">
                        +{parseFloat(displayYield).toFixed(4)} pending
                      </p>
                    )}
                  </div>
                </div>
              );
            })}
          </div>

          <div className="mt-4 p-3 bg-blue-50 rounded-lg">
            <p className="text-sm text-blue-700">
              Super Assets automatically earn yield from holding and using them on Superposition.
            </p>
          </div>
        </div>
      );
    }
  `);
}

/**
 * Generate Super Assets documentation
 */
export function generateSuperAssetsDocs(config: Config): string {
  return dedent(`
    # Super Assets Integration

    This module provides utilities for working with Super Assets on Superposition.

    ## Overview

    Super Assets are yield-bearing wrapped tokens that pay rewards for both holding AND using them.
    When you bridge assets to Superposition, they automatically become Super Assets.

    ## Key Features

    - **Passive Yield**: Earn yield just by holding Super Assets
    - **Active Yield**: Earn additional rewards when using them in transactions
    - **Utility Mining**: Every transaction earns potential token rewards

    ## Supported Super Assets

    ${config.assets.includes('all') ? `
    - **sUSDC** - Super USDC
    - **sETH** - Super ETH
    - **sWETH** - Super WETH
    ` : config.assets.map(a => `- **${a}**`).join('\n    ')}

    ## Usage

    ### Wrapping/Unwrapping

    \`\`\`typescript
    import { useSuperAsset } from './hooks/useSuperAsset';

    function WrapComponent() {
      const { wrap, unwrap, status } = useSuperAsset('sUSDC');

      const handleWrap = async () => {
        await wrap(parseUnits('100', 6)); // Wrap 100 USDC to sUSDC
      };

      const handleUnwrap = async () => {
        await unwrap(parseUnits('100', 6)); // Unwrap 100 sUSDC to USDC
      };
    }
    \`\`\`

    ${config.generateYieldTracking ? `
    ### Tracking Yield

    \`\`\`typescript
    import { useSuperAssetYield } from './hooks/useSuperAssetYield';

    function YieldDisplay() {
      const { pendingYield, currentApy, claimYield } = useSuperAssetYield('sUSDC');

      return (
        <div>
          <p>Current APY: {currentApy}%</p>
          <p>Pending Yield: {formatUnits(pendingYield, 6)} sUSDC</p>
          <button onClick={claimYield}>Claim Yield</button>
        </div>
      );
    }
    \`\`\`
    ` : ''}

    ${config.generateBalanceDisplay ? `
    ### Balance Display

    \`\`\`typescript
    import { SuperAssetBalanceDisplay } from './components/SuperAssetBalanceDisplay';

    function Dashboard() {
      return <SuperAssetBalanceDisplay />;
    }
    \`\`\`
    ` : ''}

    ## Resources

    - [Super Assets Documentation](https://docs.superposition.so/superposition-mainnet/super-layer/super-assets)
    - [Superposition Bridge](https://bridge.superposition.so)
  `);
}
