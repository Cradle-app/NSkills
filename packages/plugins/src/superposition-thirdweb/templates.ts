import type { z } from 'zod';
import type { SuperpositionThirdwebConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof SuperpositionThirdwebConfig>;

/**
 * Generate Thirdweb types
 */
export function generateThirdwebTypes(): string {
  return dedent(`
    // Superposition Thirdweb Types
    // Generated by Cradle - https://www.nskills.xyz

    import type { ThirdwebClient } from 'thirdweb';
    import type { Chain } from 'thirdweb/chains';

    export interface ThirdwebConfig {
      client: ThirdwebClient;
      chain: Chain;
    }

    export interface DeployContractOptions {
      contractType: 'token' | 'nft-collection' | 'nft-drop' | 'token-drop' | 'marketplace' | 'custom';
      name: string;
      symbol?: string;
      description?: string;
      image?: string;
      royaltyBps?: number;
      royaltyRecipient?: string;
      platformFeeBps?: number;
      platformFeeRecipient?: string;
    }

    export interface DeployedContract {
      address: string;
      transactionHash: string;
      chainId: number;
      contractType: string;
    }

    export type DeployStatus = 'idle' | 'preparing' | 'deploying' | 'success' | 'error';

    export interface UseThirdwebSuperpositionReturn {
      status: DeployStatus;
      error: Error | null;
      deployedContract: DeployedContract | null;
      isLoading: boolean;
      deployContract: (options: DeployContractOptions) => Promise<DeployedContract>;
      deployPublishedContract: (
        publisher: string,
        contractId: string,
        constructorParams?: unknown[]
      ) => Promise<DeployedContract>;
      reset: () => void;
    }
  `);
}

/**
 * Generate Thirdweb client configuration
 */
export function generateThirdwebConfig(): string {
  return dedent(`
    // Superposition Thirdweb Configuration
    // Generated by Cradle - https://www.nskills.xyz

    import { createThirdwebClient, defineChain } from 'thirdweb';

    /**
     * Thirdweb client instance
     * Configure with your client ID from https://thirdweb.com/dashboard
     */
    export const thirdwebClient = createThirdwebClient({
      clientId: process.env.NEXT_PUBLIC_THIRDWEB_CLIENT_ID!,
    });

    /**
     * Superposition Mainnet chain configuration for Thirdweb
     */
    export const superpositionChain = defineChain({
      id: 55244,
      name: 'Superposition',
      nativeCurrency: {
        name: 'ETH',
        symbol: 'ETH',
        decimals: 18,
      },
      rpc: 'https://rpc.superposition.so',
      blockExplorers: [
        {
          name: 'Superposition Explorer',
          url: 'https://explorer.superposition.so',
        },
      ],
    });

    /**
     * Superposition Testnet chain configuration for Thirdweb
     */
    export const superpositionTestnetChain = defineChain({
      id: 98985,
      name: 'Superposition Testnet',
      nativeCurrency: {
        name: 'SPN',
        symbol: 'SPN',
        decimals: 18,
      },
      rpc: 'https://testnet-rpc.superposition.so',
      blockExplorers: [
        {
          name: 'Superposition Testnet Explorer',
          url: 'https://testnet-explorer.superposition.so',
        },
      ],
      testnet: true,
    });

    /**
     * Get chain by network name
     */
    export function getSuperpositionChain(network: 'mainnet' | 'testnet' = 'mainnet') {
      return network === 'testnet' ? superpositionTestnetChain : superpositionChain;
    }

    /**
     * Thirdweb configuration for Superposition
     */
    export const thirdwebSuperpositionConfig = {
      client: thirdwebClient,
      chain: superpositionChain,
      testnetChain: superpositionTestnetChain,
    } as const;
  `);
}

/**
 * Generate Thirdweb deploy hook
 */
export function generateDeployHook(config: Config): string {
  const includeNFT = config.features.includes('nft-drops') || config.features.includes('deploy-contract');
  const includeToken = config.features.includes('token-drops') || config.features.includes('deploy-contract');

  return dedent(`
    // Superposition Thirdweb Deploy Hook
    // Generated by Cradle - https://www.nskills.xyz

    'use client';

    import { useState, useCallback } from 'react';
    import { useActiveAccount } from 'thirdweb/react';
    import { 
      deployERC20Contract,
      deployERC721Contract,
      deployERC1155Contract,
    } from 'thirdweb/deploys';
    import { thirdwebClient, superpositionChain } from '../lib/thirdweb';
    import type { 
      DeployContractOptions, 
      DeployedContract, 
      DeployStatus,
      UseThirdwebSuperpositionReturn,
    } from '../types/thirdweb';

    /**
     * Hook for deploying contracts on Superposition using Thirdweb
     */
    export function useThirdwebSuperposition(): UseThirdwebSuperpositionReturn {
      const account = useActiveAccount();
      const [status, setStatus] = useState<DeployStatus>('idle');
      const [error, setError] = useState<Error | null>(null);
      const [deployedContract, setDeployedContract] = useState<DeployedContract | null>(null);

      const isLoading = status === 'preparing' || status === 'deploying';

      /**
       * Deploy a contract based on type
       */
      const deployContract = useCallback(
        async (options: DeployContractOptions): Promise<DeployedContract> => {
          if (!account) {
            throw new Error('No wallet connected');
          }

          setStatus('preparing');
          setError(null);

          try {
            let contractAddress: string;

            switch (options.contractType) {
              ${includeToken ? `
              case 'token':
              case 'token-drop': {
                const result = await deployERC20Contract({
                  chain: superpositionChain,
                  client: thirdwebClient,
                  account,
                  type: options.contractType === 'token-drop' ? 'DropERC20' : 'TokenERC20',
                  params: {
                    name: options.name,
                    symbol: options.symbol || options.name.substring(0, 4).toUpperCase(),
                    description: options.description,
                  },
                });
                contractAddress = result;
                break;
              }` : ''}
              ${includeNFT ? `
              case 'nft-collection':
              case 'nft-drop': {
                const result = await deployERC721Contract({
                  chain: superpositionChain,
                  client: thirdwebClient,
                  account,
                  type: options.contractType === 'nft-drop' ? 'DropERC721' : 'TokenERC721',
                  params: {
                    name: options.name,
                    symbol: options.symbol || options.name.substring(0, 4).toUpperCase(),
                    description: options.description,
                    image: options.image,
                    royaltyBps: options.royaltyBps ? BigInt(options.royaltyBps) : undefined,
                    royaltyRecipient: options.royaltyRecipient,
                  },
                });
                contractAddress = result;
                break;
              }
              case 'marketplace': {
                const result = await deployERC1155Contract({
                  chain: superpositionChain,
                  client: thirdwebClient,
                  account,
                  type: 'DropERC1155',
                  params: {
                    name: options.name,
                    description: options.description,
                  },
                });
                contractAddress = result;
                break;
              }` : ''}
              default:
                throw new Error(\`Unsupported contract type: \${options.contractType}\`);
            }

            setStatus('deploying');

            const deployed: DeployedContract = {
              address: contractAddress,
              transactionHash: '', // Transaction hash from deployment
              chainId: superpositionChain.id,
              contractType: options.contractType,
            };

            setDeployedContract(deployed);
            setStatus('success');

            return deployed;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Deployment failed');
            setError(error);
            setStatus('error');
            throw error;
          }
        },
        [account]
      );

      /**
       * Deploy a published contract from Thirdweb registry
       */
      const deployPublishedContract = useCallback(
        async (
          publisher: string,
          contractId: string,
          constructorParams: unknown[] = []
        ): Promise<DeployedContract> => {
          if (!account) {
            throw new Error('No wallet connected');
          }

          setStatus('preparing');
          setError(null);

          try {
            // For published contracts, we use the generic deploy flow
            // This requires the thirdweb/deploys package
            const { deployPublishedContract: deploy } = await import('thirdweb/deploys');
            
            setStatus('deploying');

            const contractAddress = await deploy({
              chain: superpositionChain,
              client: thirdwebClient,
              account,
              contractId,
              publisher,
              contractParams: constructorParams,
            });

            const deployed: DeployedContract = {
              address: contractAddress,
              transactionHash: '',
              chainId: superpositionChain.id,
              contractType: 'published',
            };

            setDeployedContract(deployed);
            setStatus('success');

            return deployed;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Deployment failed');
            setError(error);
            setStatus('error');
            throw error;
          }
        },
        [account]
      );

      const reset = useCallback(() => {
        setStatus('idle');
        setError(null);
        setDeployedContract(null);
      }, []);

      return {
        status,
        error,
        deployedContract,
        isLoading,
        deployContract,
        deployPublishedContract,
        reset,
      };
    }
  `);
}

/**
 * Generate contract interaction hook
 */
export function generateContractHook(): string {
  return dedent(`
    // Superposition Contract Interaction Hook
    // Generated by Cradle - https://www.nskills.xyz

    'use client';

    import { useState, useCallback, useMemo } from 'react';
    import { useActiveAccount, useReadContract, useSendTransaction } from 'thirdweb/react';
    import { getContract, prepareContractCall } from 'thirdweb';
    import { thirdwebClient, superpositionChain } from '../lib/thirdweb';
    import type { Abi } from 'abitype';

    export interface UseContractOptions {
      address: string;
      abi?: Abi;
    }

    export interface UseContractReturn<T = unknown> {
      contract: ReturnType<typeof getContract>;
      read: <R = T>(functionName: string, args?: unknown[]) => Promise<R>;
      write: (functionName: string, args?: unknown[], value?: bigint) => Promise<string>;
      isLoading: boolean;
      error: Error | null;
    }

    /**
     * Hook for interacting with contracts on Superposition
     */
    export function useSuperpositionContract<T = unknown>(
      options: UseContractOptions
    ): UseContractReturn<T> {
      const account = useActiveAccount();
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<Error | null>(null);

      const contract = useMemo(() => {
        return getContract({
          client: thirdwebClient,
          chain: superpositionChain,
          address: options.address as \`0x\${string}\`,
          abi: options.abi,
        });
      }, [options.address, options.abi]);

      const { mutateAsync: sendTransaction } = useSendTransaction();

      const read = useCallback(
        async <R = T>(functionName: string, args: unknown[] = []): Promise<R> => {
          setIsLoading(true);
          setError(null);

          try {
            const { data } = useReadContract({
              contract,
              method: functionName as any,
              params: args,
            });
            return data as R;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Read failed');
            setError(error);
            throw error;
          } finally {
            setIsLoading(false);
          }
        },
        [contract]
      );

      const write = useCallback(
        async (functionName: string, args: unknown[] = [], value?: bigint): Promise<string> => {
          if (!account) {
            throw new Error('No wallet connected');
          }

          setIsLoading(true);
          setError(null);

          try {
            const transaction = prepareContractCall({
              contract,
              method: functionName as any,
              params: args,
              value,
            });

            const result = await sendTransaction(transaction);
            return result.transactionHash;
          } catch (err) {
            const error = err instanceof Error ? err : new Error('Write failed');
            setError(error);
            throw error;
          } finally {
            setIsLoading(false);
          }
        },
        [account, contract, sendTransaction]
      );

      return {
        contract,
        read,
        write,
        isLoading,
        error,
      };
    }
  `);
}

/**
 * Generate Thirdweb Provider component
 */
export function generateThirdwebProvider(): string {
  return dedent(`
    // Superposition Thirdweb Provider
    // Generated by Cradle - https://www.nskills.xyz

    'use client';

    import { ThirdwebProvider } from 'thirdweb/react';
    import { thirdwebClient, superpositionChain, superpositionTestnetChain } from '../lib/thirdweb';

    interface SuperpositionThirdwebProviderProps {
      children: React.ReactNode;
      network?: 'mainnet' | 'testnet';
    }

    /**
     * Thirdweb Provider configured for Superposition
     */
    export function SuperpositionThirdwebProvider({
      children,
      network = 'mainnet',
    }: SuperpositionThirdwebProviderProps) {
      const chain = network === 'testnet' ? superpositionTestnetChain : superpositionChain;

      return (
        <ThirdwebProvider>
          {children}
        </ThirdwebProvider>
      );
    }

    export default SuperpositionThirdwebProvider;
  `);
}

/**
 * Generate prebuilt contracts helpers
 */
export function generatePrebuiltContracts(): string {
  return dedent(`
    // Superposition Prebuilt Contracts
    // Generated by Cradle - https://www.nskills.xyz

    /**
     * Common prebuilt contract configurations for Superposition
     */
    export const PREBUILT_CONTRACTS = {
      // Token contracts
      token: {
        name: 'Token',
        description: 'Standard ERC20 token with mint capability',
        publisher: 'thirdweb.eth',
        contractId: 'TokenERC20',
      },
      tokenDrop: {
        name: 'Token Drop',
        description: 'ERC20 token with claimable distribution',
        publisher: 'thirdweb.eth',
        contractId: 'DropERC20',
      },

      // NFT contracts
      nftCollection: {
        name: 'NFT Collection',
        description: 'Standard ERC721 NFT collection',
        publisher: 'thirdweb.eth',
        contractId: 'TokenERC721',
      },
      nftDrop: {
        name: 'NFT Drop',
        description: 'ERC721 with lazy minting and claim phases',
        publisher: 'thirdweb.eth',
        contractId: 'DropERC721',
      },
      edition: {
        name: 'Edition',
        description: 'ERC1155 multi-token collection',
        publisher: 'thirdweb.eth',
        contractId: 'TokenERC1155',
      },
      editionDrop: {
        name: 'Edition Drop',
        description: 'ERC1155 with claimable distribution',
        publisher: 'thirdweb.eth',
        contractId: 'DropERC1155',
      },

      // Marketplace
      marketplace: {
        name: 'Marketplace',
        description: 'NFT marketplace with direct listings and auctions',
        publisher: 'thirdweb.eth',
        contractId: 'MarketplaceV3',
      },

      // Utility
      split: {
        name: 'Split',
        description: 'Revenue splitting contract',
        publisher: 'thirdweb.eth',
        contractId: 'Split',
      },
      vote: {
        name: 'Vote',
        description: 'On-chain governance voting',
        publisher: 'thirdweb.eth',
        contractId: 'VoteERC20',
      },
    } as const;

    export type PrebuiltContractType = keyof typeof PREBUILT_CONTRACTS;

    /**
     * Get prebuilt contract configuration
     */
    export function getPrebuiltContract(type: PrebuiltContractType) {
      return PREBUILT_CONTRACTS[type];
    }
  `);
}

/**
 * Generate documentation
 */
export function generateThirdwebDocs(config: Config): string {
  return dedent(`
    # Thirdweb on Superposition

    Deploy and interact with smart contracts on Superposition using the Thirdweb SDK.

    ## Overview

    This integration provides:
    - Pre-configured Thirdweb client for Superposition
    - Contract deployment helpers (tokens, NFTs, marketplaces)
    - React hooks for contract interactions
    - Support for both mainnet and testnet

    ## Setup

    ### 1. Get a Thirdweb Client ID

    1. Go to [Thirdweb Dashboard](https://thirdweb.com/dashboard)
    2. Create a new API key
    3. Add the client ID to your environment:

    \`\`\`bash
    NEXT_PUBLIC_THIRDWEB_CLIENT_ID=your_client_id_here
    \`\`\`

    ### 2. Wrap Your App

    \`\`\`tsx
    import { SuperpositionThirdwebProvider } from './providers/SuperpositionThirdwebProvider';

    function App({ children }) {
      return (
        <SuperpositionThirdwebProvider>
          {children}
        </SuperpositionThirdwebProvider>
      );
    }
    \`\`\`

    ## Usage

    ### Deploy a Token

    \`\`\`typescript
    import { useThirdwebSuperposition } from './hooks/useThirdwebSuperposition';

    function DeployToken() {
      const { deployContract, isLoading, deployedContract } = useThirdwebSuperposition();

      const handleDeploy = async () => {
        const contract = await deployContract({
          contractType: 'token',
          name: 'My Token',
          symbol: 'MTK',
        });
        console.log('Deployed at:', contract.address);
      };

      return (
        <button onClick={handleDeploy} disabled={isLoading}>
          {isLoading ? 'Deploying...' : 'Deploy Token'}
        </button>
      );
    }
    \`\`\`

    ### Deploy an NFT Collection

    \`\`\`typescript
    const { deployContract } = useThirdwebSuperposition();

    const contract = await deployContract({
      contractType: 'nft-drop',
      name: 'My NFT Collection',
      symbol: 'MNFT',
      royaltyBps: 500, // 5%
      royaltyRecipient: '0x...',
    });
    \`\`\`

    ### Interact with a Contract

    \`\`\`typescript
    import { useSuperpositionContract } from './hooks/useSuperpositionContract';

    function TokenBalance() {
      const { read, write } = useSuperpositionContract({
        address: '0x...',
      });

      const balance = await read<bigint>('balanceOf', ['0x...']);
      const txHash = await write('transfer', ['0x...', 1000n]);
    }
    \`\`\`

    ## Available Contract Types

    - \`token\` - Standard ERC20 token
    - \`token-drop\` - ERC20 with claimable distribution
    - \`nft-collection\` - Standard ERC721
    - \`nft-drop\` - ERC721 with lazy minting
    - \`marketplace\` - NFT marketplace

    ## Resources

    - [Thirdweb Documentation](https://portal.thirdweb.com)
    - [Superposition Documentation](https://docs.superposition.so)
  `);
}
