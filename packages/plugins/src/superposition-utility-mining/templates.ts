import type { z } from 'zod';
import type { SuperpositionUtilityMiningConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof SuperpositionUtilityMiningConfig>;

/**
 * Generate Utility Mining types
 */
export function generateUtilityMiningTypes(): string {
  return dedent(`
    // Superposition Utility Mining Types
    // Generated by Cradle - https://cradle.dev

    import type { Address } from 'viem';

    export type TransactionType = 'swap' | 'transfer' | 'nft-purchase' | 'liquidity' | 'other';

    export interface RewardInfo {
      pendingRewards: bigint;
      claimableRewards: bigint;
      totalEarned: bigint;
      lastClaimTimestamp: number;
    }

    export interface RewardHistoryItem {
      id: string;
      transactionHash: string;
      transactionType: TransactionType;
      amount: bigint;
      timestamp: number;
      blockNumber: bigint;
    }

    export interface LeaderboardEntry {
      rank: number;
      address: Address;
      totalRewards: bigint;
      transactionCount: number;
    }

    export type RewardStatus = 'idle' | 'loading' | 'claiming' | 'success' | 'error';

    export interface UseUtilityMiningRewardsReturn {
      status: RewardStatus;
      rewards: RewardInfo | null;
      rewardHistory: RewardHistoryItem[];
      error: Error | null;
      isLoading: boolean;
      isClaiming: boolean;
      refetch: () => Promise<void>;
      claimRewards: () => Promise<string>;
    }

    export interface UseLeaderboardReturn {
      entries: LeaderboardEntry[];
      userRank: number | null;
      isLoading: boolean;
      error: Error | null;
      refetch: () => Promise<void>;
    }
  `);
}

/**
 * Generate Utility Mining constants
 */
export function generateUtilityMiningConstants(): string {
  return dedent(`
    // Superposition Utility Mining Constants
    // Generated by Cradle - https://cradle.dev

    import type { Address } from 'viem';

    /**
     * Utility Mining contract addresses
     * 
     * NOTE: These contract addresses are not yet publicly documented.
     * Utility Mining is part of Superposition's TRF (Transfer Reward Function) system.
     * 
     * For updates, check:
     * - https://docs.superposition.so/superposition-mainnet/super-layer/utility-mining
     * - https://docs.fluidity.money/docs/fundamentals/utility-mining
     * - Contact the Superposition team for verified addresses
     */
    export const UTILITY_MINING_CONTRACTS = {
      mainnet: {
        // TODO: Reward Distributor - distributes utility mining rewards
        // Check: https://docs.superposition.so for verified address
        rewardDistributor: '0x0000000000000000000000000000000000000000' as Address,
        
        // TODO: TRF Registry - registers eligible transactions for rewards
        // Check: https://docs.fluidity.money for TRF documentation
        trfRegistry: '0x0000000000000000000000000000000000000000' as Address,
      },
      testnet: {
        // TODO: Testnet reward contracts not yet documented
        rewardDistributor: '0x0000000000000000000000000000000000000000' as Address,
        trfRegistry: '0x0000000000000000000000000000000000000000' as Address,
      },
    } as const;

    /**
     * Utility Mining configuration
     */
    export const UTILITY_MINING_CONFIG = {
      // Minimum rewards threshold for claiming (in wei)
      minClaimThreshold: BigInt('1000000000000000'), // 0.001 ETH
      
      // Claim cooldown period (in seconds)
      claimCooldown: 3600, // 1 hour
      
      // Reward calculation constants
      baseRewardMultiplier: 100,
      swapBonus: 150, // 1.5x for swaps
      liquidityBonus: 200, // 2x for liquidity provision
      
      // API endpoints
      apiBaseUrl: 'https://api.superposition.so',
      rewardsEndpoint: '/v1/utility-mining/rewards',
      historyEndpoint: '/v1/utility-mining/history',
      leaderboardEndpoint: '/v1/utility-mining/leaderboard',
    } as const;

    /**
     * Supported transaction types for utility mining
     */
    export const TRANSACTION_TYPES = [
      { id: 'swap', label: 'Token Swap', multiplier: 1.5 },
      { id: 'transfer', label: 'Token Transfer', multiplier: 1.0 },
      { id: 'nft-purchase', label: 'NFT Purchase', multiplier: 1.2 },
      { id: 'liquidity', label: 'Liquidity Provision', multiplier: 2.0 },
    ] as const;
  `);
}

/**
 * Generate Utility Mining ABIs
 */
export function generateUtilityMiningABIs(): string {
  return dedent(`
    // Superposition Utility Mining ABIs
    // Generated by Cradle - https://cradle.dev

    /**
     * Reward Distributor ABI (simplified)
     */
    export const REWARD_DISTRIBUTOR_ABI = [
      {
        inputs: [{ name: 'user', type: 'address' }],
        name: 'getPendingRewards',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ name: 'user', type: 'address' }],
        name: 'getClaimableRewards',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ name: 'user', type: 'address' }],
        name: 'getTotalEarned',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ name: 'user', type: 'address' }],
        name: 'getLastClaimTimestamp',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [],
        name: 'claimRewards',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'nonpayable',
        type: 'function',
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, name: 'user', type: 'address' },
          { indexed: false, name: 'amount', type: 'uint256' },
          { indexed: false, name: 'timestamp', type: 'uint256' },
        ],
        name: 'RewardsClaimed',
        type: 'event',
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, name: 'user', type: 'address' },
          { indexed: false, name: 'amount', type: 'uint256' },
          { indexed: false, name: 'transactionType', type: 'string' },
        ],
        name: 'RewardsEarned',
        type: 'event',
      },
    ] as const;

    /**
     * TRF (Transfer Rewards Function) Registry ABI
     */
    export const TRF_REGISTRY_ABI = [
      {
        inputs: [{ name: 'token', type: 'address' }],
        name: 'isEligibleForRewards',
        outputs: [{ name: '', type: 'bool' }],
        stateMutability: 'view',
        type: 'function',
      },
      {
        inputs: [{ name: 'token', type: 'address' }],
        name: 'getRewardMultiplier',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function',
      },
    ] as const;
  `);
}

/**
 * Generate Utility Mining rewards hook
 */
export function generateRewardsHook(config: Config): string {
  return dedent(`
    // Superposition Utility Mining Rewards Hook
    // Generated by Cradle - https://cradle.dev

    'use client';

    import { useState, useCallback, useEffect } from 'react';
    import { useAccount, usePublicClient, useWalletClient } from 'wagmi';
    import { type Address } from 'viem';
    import { UTILITY_MINING_CONTRACTS, UTILITY_MINING_CONFIG } from '../config/utility-mining-constants';
    import { REWARD_DISTRIBUTOR_ABI } from '../config/utility-mining-abi';
    import type {
      RewardInfo,
      RewardHistoryItem,
      RewardStatus,
      UseUtilityMiningRewardsReturn,
    } from '../types/utility-mining';

    interface UseUtilityMiningOptions {
      network?: 'mainnet' | 'testnet';
      autoRefresh?: boolean;
      refreshInterval?: number;
    }

    /**
     * Hook for tracking and claiming utility mining rewards
     */
    export function useUtilityMiningRewards(
      options: UseUtilityMiningOptions = {}
    ): UseUtilityMiningRewardsReturn {
      const { network = 'mainnet', autoRefresh = true, refreshInterval = 30000 } = options;
      
      const { address } = useAccount();
      const publicClient = usePublicClient();
      const { data: walletClient } = useWalletClient();

      const [status, setStatus] = useState<RewardStatus>('idle');
      const [rewards, setRewards] = useState<RewardInfo | null>(null);
      const [rewardHistory, setRewardHistory] = useState<RewardHistoryItem[]>([]);
      const [error, setError] = useState<Error | null>(null);

      const isLoading = status === 'loading';
      const isClaiming = status === 'claiming';

      const contracts = UTILITY_MINING_CONTRACTS[network];

      /**
       * Fetch reward information
       */
      const fetchRewards = useCallback(async () => {
        if (!address || !publicClient) return;

        setStatus('loading');
        setError(null);

        try {
          // Fetch on-chain reward data
          const [pendingRewards, claimableRewards, totalEarned, lastClaimTimestamp] = await Promise.all([
            publicClient.readContract({
              address: contracts.rewardDistributor,
              abi: REWARD_DISTRIBUTOR_ABI,
              functionName: 'getPendingRewards',
              args: [address],
            }),
            publicClient.readContract({
              address: contracts.rewardDistributor,
              abi: REWARD_DISTRIBUTOR_ABI,
              functionName: 'getClaimableRewards',
              args: [address],
            }),
            publicClient.readContract({
              address: contracts.rewardDistributor,
              abi: REWARD_DISTRIBUTOR_ABI,
              functionName: 'getTotalEarned',
              args: [address],
            }),
            publicClient.readContract({
              address: contracts.rewardDistributor,
              abi: REWARD_DISTRIBUTOR_ABI,
              functionName: 'getLastClaimTimestamp',
              args: [address],
            }),
          ]);

          setRewards({
            pendingRewards: pendingRewards as bigint,
            claimableRewards: claimableRewards as bigint,
            totalEarned: totalEarned as bigint,
            lastClaimTimestamp: Number(lastClaimTimestamp),
          });

          ${config.generateRewardHistory ? `
          // Fetch reward history from API
          const historyResponse = await fetch(
            \`\${UTILITY_MINING_CONFIG.apiBaseUrl}\${UTILITY_MINING_CONFIG.historyEndpoint}?address=\${address}\`
          );
          
          if (historyResponse.ok) {
            const historyData = await historyResponse.json();
            setRewardHistory(historyData.items || []);
          }
          ` : ''}

          setStatus('idle');
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Failed to fetch rewards');
          setError(error);
          setStatus('error');
        }
      }, [address, publicClient, contracts.rewardDistributor]);

      /**
       * Claim pending rewards
       */
      const claimRewards = useCallback(async (): Promise<string> => {
        if (!address || !walletClient || !publicClient) {
          throw new Error('Wallet not connected');
        }

        if (!rewards?.claimableRewards || rewards.claimableRewards === 0n) {
          throw new Error('No rewards to claim');
        }

        setStatus('claiming');
        setError(null);

        try {
          const { request } = await publicClient.simulateContract({
            address: contracts.rewardDistributor,
            abi: REWARD_DISTRIBUTOR_ABI,
            functionName: 'claimRewards',
            account: address,
          });

          const hash = await walletClient.writeContract(request);

          // Wait for confirmation
          await publicClient.waitForTransactionReceipt({ hash });

          // Refresh rewards after claiming
          await fetchRewards();

          setStatus('success');
          return hash;
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Claim failed');
          setError(error);
          setStatus('error');
          throw error;
        }
      }, [address, walletClient, publicClient, contracts.rewardDistributor, rewards, fetchRewards]);

      // Initial fetch and auto-refresh
      useEffect(() => {
        if (address) {
          fetchRewards();
        }
      }, [address, fetchRewards]);

      useEffect(() => {
        if (!autoRefresh || !address) return;

        const interval = setInterval(fetchRewards, refreshInterval);
        return () => clearInterval(interval);
      }, [autoRefresh, refreshInterval, address, fetchRewards]);

      return {
        status,
        rewards,
        rewardHistory,
        error,
        isLoading,
        isClaiming,
        refetch: fetchRewards,
        claimRewards,
      };
    }
  `);
}

/**
 * Generate reward display UI component
 */
export function generateRewardUI(): string {
  return dedent(`
    // Superposition Utility Mining Reward Display
    // Generated by Cradle - https://cradle.dev

    'use client';

    import { formatEther } from 'viem';
    import { useUtilityMiningRewards } from '../hooks/useUtilityMiningRewards';

    interface RewardDisplayProps {
      network?: 'mainnet' | 'testnet';
      showHistory?: boolean;
      className?: string;
    }

    /**
     * Utility Mining Reward Display Component
     */
    export function UtilityMiningRewardDisplay({
      network = 'mainnet',
      showHistory = true,
      className = '',
    }: RewardDisplayProps) {
      const {
        rewards,
        rewardHistory,
        isLoading,
        isClaiming,
        error,
        claimRewards,
        refetch,
      } = useUtilityMiningRewards({ network });

      if (error) {
        return (
          <div className={\`utility-mining-error \${className}\`}>
            <p>Error loading rewards: {error.message}</p>
            <button onClick={refetch}>Retry</button>
          </div>
        );
      }

      if (isLoading && !rewards) {
        return (
          <div className={\`utility-mining-loading \${className}\`}>
            <p>Loading rewards...</p>
          </div>
        );
      }

      return (
        <div className={\`utility-mining-rewards \${className}\`}>
          <h3>Utility Mining Rewards</h3>
          
          {rewards && (
            <div className="rewards-summary">
              <div className="reward-item">
                <span className="label">Pending Rewards</span>
                <span className="value">{formatEther(rewards.pendingRewards)} SPN</span>
              </div>
              <div className="reward-item">
                <span className="label">Claimable</span>
                <span className="value">{formatEther(rewards.claimableRewards)} SPN</span>
              </div>
              <div className="reward-item">
                <span className="label">Total Earned</span>
                <span className="value">{formatEther(rewards.totalEarned)} SPN</span>
              </div>

              {rewards.claimableRewards > 0n && (
                <button
                  onClick={claimRewards}
                  disabled={isClaiming}
                  className="claim-button"
                >
                  {isClaiming ? 'Claiming...' : 'Claim Rewards'}
                </button>
              )}
            </div>
          )}

          {showHistory && rewardHistory.length > 0 && (
            <div className="reward-history">
              <h4>Recent Activity</h4>
              <ul>
                {rewardHistory.slice(0, 5).map((item) => (
                  <li key={item.id}>
                    <span className="type">{item.transactionType}</span>
                    <span className="amount">+{formatEther(item.amount)} SPN</span>
                    <span className="time">
                      {new Date(item.timestamp * 1000).toLocaleDateString()}
                    </span>
                  </li>
                ))}
              </ul>
            </div>
          )}
        </div>
      );
    }

    export default UtilityMiningRewardDisplay;
  `);
}

/**
 * Generate leaderboard hook
 */
export function generateLeaderboardHook(): string {
  return dedent(`
    // Superposition Utility Mining Leaderboard Hook
    // Generated by Cradle - https://cradle.dev

    'use client';

    import { useState, useCallback, useEffect } from 'react';
    import { useAccount } from 'wagmi';
    import { UTILITY_MINING_CONFIG } from '../config/utility-mining-constants';
    import type { LeaderboardEntry, UseLeaderboardReturn } from '../types/utility-mining';

    interface UseLeaderboardOptions {
      limit?: number;
      autoRefresh?: boolean;
    }

    /**
     * Hook for fetching utility mining leaderboard
     */
    export function useUtilityMiningLeaderboard(
      options: UseLeaderboardOptions = {}
    ): UseLeaderboardReturn {
      const { limit = 100, autoRefresh = false } = options;
      const { address } = useAccount();

      const [entries, setEntries] = useState<LeaderboardEntry[]>([]);
      const [userRank, setUserRank] = useState<number | null>(null);
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<Error | null>(null);

      const fetchLeaderboard = useCallback(async () => {
        setIsLoading(true);
        setError(null);

        try {
          const response = await fetch(
            \`\${UTILITY_MINING_CONFIG.apiBaseUrl}\${UTILITY_MINING_CONFIG.leaderboardEndpoint}?limit=\${limit}\`
          );

          if (!response.ok) {
            throw new Error('Failed to fetch leaderboard');
          }

          const data = await response.json();
          setEntries(data.entries || []);

          // Find user's rank if connected
          if (address) {
            const userEntry = data.entries.find(
              (e: LeaderboardEntry) => e.address.toLowerCase() === address.toLowerCase()
            );
            setUserRank(userEntry?.rank ?? null);
          }
        } catch (err) {
          const error = err instanceof Error ? err : new Error('Failed to fetch leaderboard');
          setError(error);
        } finally {
          setIsLoading(false);
        }
      }, [limit, address]);

      useEffect(() => {
        fetchLeaderboard();
      }, [fetchLeaderboard]);

      useEffect(() => {
        if (!autoRefresh) return;
        const interval = setInterval(fetchLeaderboard, 60000);
        return () => clearInterval(interval);
      }, [autoRefresh, fetchLeaderboard]);

      return {
        entries,
        userRank,
        isLoading,
        error,
        refetch: fetchLeaderboard,
      };
    }
  `);
}

/**
 * Generate documentation
 */
export function generateUtilityMiningDocs(config: Config): string {
  return dedent(`
    # Superposition Utility Mining

    Track and claim rewards from on-chain activity on Superposition.

    ## Overview

    Utility Mining is Superposition's unique token distribution mechanism that rewards users for on-chain activity. Unlike traditional staking, you earn rewards by actually using the network.

    ### How it Works

    1. **Perform Transactions**: Swaps, transfers, NFT purchases, and liquidity provision
    2. **Earn Rewards**: Each transaction accumulates SPN rewards based on activity type
    3. **Claim Rewards**: Collect your accumulated rewards when ready

    ### Reward Multipliers

    | Activity | Multiplier |
    |----------|------------|
    | Token Swap | 1.5x |
    | Token Transfer | 1.0x |
    | NFT Purchase | 1.2x |
    | Liquidity Provision | 2.0x |

    ## Usage

    ### Track Rewards

    \`\`\`typescript
    import { useUtilityMiningRewards } from './hooks/useUtilityMiningRewards';

    function RewardsTracker() {
      const { rewards, isLoading, claimRewards } = useUtilityMiningRewards();

      if (isLoading) return <p>Loading...</p>;

      return (
        <div>
          <p>Pending: {formatEther(rewards?.pendingRewards ?? 0n)} SPN</p>
          <p>Claimable: {formatEther(rewards?.claimableRewards ?? 0n)} SPN</p>
          <button onClick={claimRewards}>Claim Rewards</button>
        </div>
      );
    }
    \`\`\`

    ### Use the Pre-built Component

    \`\`\`tsx
    import { UtilityMiningRewardDisplay } from './components/UtilityMiningRewardDisplay';

    function App() {
      return <UtilityMiningRewardDisplay showHistory={true} />;
    }
    \`\`\`

    ${config.includeLeaderboard ? `
    ### View Leaderboard

    \`\`\`typescript
    import { useUtilityMiningLeaderboard } from './hooks/useUtilityMiningLeaderboard';

    function Leaderboard() {
      const { entries, userRank } = useUtilityMiningLeaderboard();

      return (
        <div>
          {userRank && <p>Your Rank: #{userRank}</p>}
          {entries.map((entry) => (
            <div key={entry.address}>
              #{entry.rank} - {entry.address} - {formatEther(entry.totalRewards)} SPN
            </div>
          ))}
        </div>
      );
    }
    \`\`\`
    ` : ''}

    ## Resources

    - [Superposition Utility Mining Docs](https://docs.superposition.so/the-super-layer/utility-mining)
    - [Whitepaper](https://whitepapers.fluidity.money/spn-whitepaper-0.1.pdf)
  `);
}
