import type { z } from 'zod';
import type { X402PaywallConfig, BlueprintConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof X402PaywallConfig>;

/**
 * Generate TypeScript types for payment handling
 */
export function generatePaymentTypes(config: Config): string {
  return dedent(`
    // x402 Payment Types
    // Generated by [N]skills

    export interface PaymentReceipt {
      txHash: string;
      blockNumber: number;
      from: string;
      to: string;
      amount: string;
      timestamp: number;
      chainId: number;
    }

    export interface PaymentRequirements {
      address: string;
      amount: string;
      currency: '${config.currency}';
      chainId: number;
      timeout: number;
      ${config.customTokenAddress ? `tokenAddress: string;` : ''}
    }

    export interface X402Headers {
      'X-Payment-Address': string;
      'X-Payment-Amount': string;
      'X-Payment-Currency': string;
      'X-Payment-Chain-ID': string;
      'X-Payment-Timeout': string;
      ${config.customTokenAddress ? `'X-Payment-Token': string;` : ''}
    }

    export interface PaymentVerificationResult {
      valid: boolean;
      error?: string;
      receipt?: PaymentReceipt;
    }

    export function createPaymentRequiredHeaders(requirements: PaymentRequirements): X402Headers {
      return {
        'X-Payment-Address': requirements.address,
        'X-Payment-Amount': requirements.amount,
        'X-Payment-Currency': requirements.currency,
        'X-Payment-Chain-ID': String(requirements.chainId),
        'X-Payment-Timeout': String(requirements.timeout),
        ${config.customTokenAddress ? `'X-Payment-Token': requirements.tokenAddress,` : ''}
      };
    }

    export function parsePaymentReceipt(encoded: string): PaymentReceipt | null {
      try {
        const decoded = Buffer.from(encoded, 'base64').toString('utf-8');
        const receipt = JSON.parse(decoded) as PaymentReceipt;
        
        // Basic validation
        if (!receipt.txHash || !receipt.from || !receipt.to || !receipt.amount) {
          return null;
        }
        
        return receipt;
      } catch {
        return null;
      }
    }

    export function encodePaymentReceipt(receipt: PaymentReceipt): string {
      return Buffer.from(JSON.stringify(receipt)).toString('base64');
    }
  `);
}

/**
 * Generate payment verification middleware
 */
export function generatePaymentMiddleware(config: Config): string {
  return dedent(`
    // x402 Payment Middleware
    // Generated by [N]skills

    import type { FastifyRequest, FastifyReply, FastifyPluginCallback } from 'fastify';
    import { createPublicClient, http } from 'viem';
    import { arbitrum, arbitrumSepolia } from 'viem/chains';
    import {
      type PaymentReceipt,
      type PaymentRequirements,
      type PaymentVerificationResult,
      createPaymentRequiredHeaders,
      parsePaymentReceipt,
    } from './types';

    const PAYMENT_REQUIREMENTS: PaymentRequirements = {
      address: process.env.PAYMENT_RECEIVER_ADDRESS!,
      amount: '${config.priceInWei}',
      currency: '${config.currency}',
      chainId: parseInt(process.env.CHAIN_ID || '42161'),
      timeout: ${config.paymentTimeout},
      ${config.customTokenAddress ? `tokenAddress: process.env.PAYMENT_TOKEN_ADDRESS || '${config.customTokenAddress}',` : ''}
    };

    // Cache for verified receipts
    const verifiedReceipts = new Map<string, { timestamp: number; valid: boolean }>();
    const CACHE_TTL = 60 * 60 * 1000; // 1 hour

    export async function verifyPayment(receipt: PaymentReceipt): Promise<PaymentVerificationResult> {
      // Check cache first
      const cached = verifiedReceipts.get(receipt.txHash);
      if (cached && Date.now() - cached.timestamp < CACHE_TTL) {
        return { valid: cached.valid, receipt: cached.valid ? receipt : undefined };
      }

      try {
        const chain = PAYMENT_REQUIREMENTS.chainId === 42161 ? arbitrum : arbitrumSepolia;
        const client = createPublicClient({
          chain,
          transport: http(),
        });

        // Get transaction receipt from chain
        const txReceipt = await client.getTransactionReceipt({
          hash: receipt.txHash as \`0x\${string}\`,
        });

        if (!txReceipt) {
          return { valid: false, error: 'Transaction not found' };
        }

        // Verify transaction was successful
        if (txReceipt.status !== 'success') {
          return { valid: false, error: 'Transaction failed' };
        }

        ${config.receiptValidation ? `
        // Verify payment details
        const tx = await client.getTransaction({
          hash: receipt.txHash as \`0x\${string}\`,
        });

        if (tx.to?.toLowerCase() !== PAYMENT_REQUIREMENTS.address.toLowerCase()) {
          return { valid: false, error: 'Payment sent to wrong address' };
        }

        if (BigInt(tx.value) < BigInt(PAYMENT_REQUIREMENTS.amount)) {
          return { valid: false, error: 'Insufficient payment amount' };
        }

        // Verify timestamp is within timeout
        const block = await client.getBlock({ blockNumber: txReceipt.blockNumber });
        const txTimestamp = Number(block.timestamp);
        const currentTime = Math.floor(Date.now() / 1000);
        
        if (currentTime - txTimestamp > PAYMENT_REQUIREMENTS.timeout) {
          return { valid: false, error: 'Payment receipt expired' };
        }
        ` : ''}

        // Cache result
        verifiedReceipts.set(receipt.txHash, { timestamp: Date.now(), valid: true });
        
        return { valid: true, receipt };
      } catch (error) {
        console.error('Payment verification error:', error);
        return { valid: false, error: 'Verification failed' };
      }
    }

    export const paymentMiddleware: FastifyPluginCallback = (fastify, _opts, done) => {
      fastify.addHook('preHandler', async (request: FastifyRequest, reply: FastifyReply) => {
        // Skip for non-protected routes
        if (!request.url.startsWith('${config.resourcePath}')) {
          return;
        }

        const receiptHeader = request.headers['x-payment-receipt'] as string | undefined;

        if (!receiptHeader) {
          // No payment receipt - return 402
          const headers = createPaymentRequiredHeaders(PAYMENT_REQUIREMENTS);
          
          for (const [key, value] of Object.entries(headers)) {
            reply.header(key, value);
          }

          return reply.status(402).send({
            error: 'Payment Required',
            message: 'This resource requires payment. Include X-Payment-Receipt header with valid payment proof.',
            requirements: PAYMENT_REQUIREMENTS,
          });
        }

        // Parse and verify receipt
        const receipt = parsePaymentReceipt(receiptHeader);
        
        if (!receipt) {
          return reply.status(400).send({
            error: 'Invalid Receipt',
            message: 'Could not parse payment receipt',
          });
        }

        const verification = await verifyPayment(receipt);

        if (!verification.valid) {
          return reply.status(402).send({
            error: 'Payment Verification Failed',
            message: verification.error,
            requirements: PAYMENT_REQUIREMENTS,
          });
        }

        // Payment verified - allow request to proceed
        (request as any).paymentReceipt = receipt;
      });

      done();
    };

    ${config.webhookUrl ? `
    export async function sendPaymentWebhook(receipt: PaymentReceipt, resource: string): Promise<void> {
      try {
        const webhookUrl = process.env.PAYMENT_WEBHOOK_URL || '${config.webhookUrl}';
        
        await fetch(webhookUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            event: 'payment.received',
            receipt,
            resource,
            timestamp: new Date().toISOString(),
          }),
        });
      } catch (error) {
        console.error('Webhook delivery failed:', error);
      }
    }
    ` : ''}
  `);
}

/**
 * Generate API server code
 */
export function generateServerCode(config: Config, blueprintConfig: BlueprintConfig): string {
  return dedent(`
    // x402 Payment API Server
    // Generated by [N]skills

    import Fastify from 'fastify';
    import cors from '@fastify/cors';
    import { paymentMiddleware } from './middleware';

    const fastify = Fastify({
      logger: true,
    });

    // Register plugins
    fastify.register(cors, {
      origin: true,
      methods: ['GET', 'POST', 'PUT', 'DELETE'],
      allowedHeaders: ['Content-Type', 'X-Payment-Receipt'],
      exposedHeaders: [
        'X-Payment-Address',
        'X-Payment-Amount',
        'X-Payment-Currency',
        'X-Payment-Chain-ID',
        'X-Payment-Timeout',
      ],
    });

    // Register payment middleware
    fastify.register(paymentMiddleware);

    // Protected resource endpoint
    fastify.get('${config.resourcePath}', async (request, reply) => {
      // At this point, payment has been verified by middleware
      const receipt = (request as any).paymentReceipt;

      return {
        success: true,
        message: 'Access granted to premium resource',
        data: {
          // Your premium content here
          content: 'This is the premium content you paid for',
          accessedAt: new Date().toISOString(),
          paidWith: receipt?.txHash,
        },
      };
    });

    // Health check endpoint
    fastify.get('/health', async () => {
      return { status: 'ok', timestamp: new Date().toISOString() };
    });

    // Payment info endpoint
    fastify.get('/api/payment-info', async () => {
      return {
        resource: '${config.resourcePath}',
        price: '${config.priceInWei}',
        currency: '${config.currency}',
        chainId: parseInt(process.env.CHAIN_ID || '${blueprintConfig.network.chainId}'),
        timeout: ${config.paymentTimeout},
        receiverAddress: process.env.PAYMENT_RECEIVER_ADDRESS,
      };
    });

    // Start server
    const start = async () => {
      try {
        const port = parseInt(process.env.PORT || '3001');
        await fastify.listen({ port, host: '0.0.0.0' });
        console.log(\`Payment API server running on port \${port}\`);
      } catch (err) {
        fastify.log.error(err);
        process.exit(1);
      }
    };

    start();
  `);
}

/**
 * Generate OpenAPI specification
 */
export function generateOpenAPISpec(config: Config, blueprintConfig: BlueprintConfig): string {
  return dedent(`
    openapi: '3.1.0'
    info:
      title: x402 Payment API
      version: '1.0.0'
      description: |
        API with x402 protocol support for HTTP-native payments.
        
        ## Payment Flow
        1. Request the protected resource
        2. Receive 402 with payment requirements in headers
        3. Submit payment on-chain
        4. Retry request with X-Payment-Receipt header

    servers:
      - url: http://localhost:3001
        description: Development server

    paths:
      ${config.resourcePath}:
        get:
          summary: Access premium resource
          description: Protected resource requiring x402 payment
          operationId: getPremiumResource
          parameters:
            - name: X-Payment-Receipt
              in: header
              required: false
              description: Base64-encoded payment receipt
              schema:
                type: string
          responses:
            '200':
              description: Access granted
              content:
                application/json:
                  schema:
                    type: object
                    properties:
                      success:
                        type: boolean
                      message:
                        type: string
                      data:
                        type: object
            '402':
              description: Payment required
              headers:
                X-Payment-Address:
                  schema:
                    type: string
                  description: Address to send payment to
                X-Payment-Amount:
                  schema:
                    type: string
                  description: Payment amount in wei
                X-Payment-Currency:
                  schema:
                    type: string
                    enum: [ETH, USDC, USDT, DAI, CUSTOM]
                X-Payment-Chain-ID:
                  schema:
                    type: string
                  description: Blockchain chain ID
                X-Payment-Timeout:
                  schema:
                    type: string
                  description: Receipt validity window in seconds
              content:
                application/json:
                  schema:
                    $ref: '#/components/schemas/PaymentRequired'

      /api/payment-info:
        get:
          summary: Get payment information
          operationId: getPaymentInfo
          responses:
            '200':
              description: Payment configuration
              content:
                application/json:
                  schema:
                    $ref: '#/components/schemas/PaymentInfo'

      /health:
        get:
          summary: Health check
          operationId: healthCheck
          responses:
            '200':
              description: Service is healthy
              content:
                application/json:
                  schema:
                    type: object
                    properties:
                      status:
                        type: string
                      timestamp:
                        type: string
                        format: date-time

    components:
      schemas:
        PaymentRequired:
          type: object
          properties:
            error:
              type: string
            message:
              type: string
            requirements:
              $ref: '#/components/schemas/PaymentRequirements'

        PaymentRequirements:
          type: object
          properties:
            address:
              type: string
              description: Payment receiver address
            amount:
              type: string
              description: Payment amount in wei
              example: '${config.priceInWei}'
            currency:
              type: string
              enum: [ETH, USDC, USDT, DAI, CUSTOM]
              example: '${config.currency}'
            chainId:
              type: integer
              example: ${blueprintConfig.network.chainId}
            timeout:
              type: integer
              description: Receipt validity in seconds
              example: ${config.paymentTimeout}

        PaymentInfo:
          type: object
          properties:
            resource:
              type: string
            price:
              type: string
            currency:
              type: string
            chainId:
              type: integer
            timeout:
              type: integer
            receiverAddress:
              type: string

        PaymentReceipt:
          type: object
          required:
            - txHash
            - blockNumber
            - from
            - to
            - amount
            - timestamp
          properties:
            txHash:
              type: string
              description: Transaction hash
            blockNumber:
              type: integer
              description: Block number
            from:
              type: string
              description: Sender address
            to:
              type: string
              description: Receiver address
            amount:
              type: string
              description: Amount in wei
            timestamp:
              type: integer
              description: Unix timestamp
            chainId:
              type: integer
              description: Chain ID
  `);
}

