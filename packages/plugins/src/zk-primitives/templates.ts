import type { z } from 'zod';
import type { ZKPrimitivesConfig } from '@dapp-forge/blueprint-schema';
import { dedent } from '@dapp-forge/plugin-sdk';

type Config = z.infer<typeof ZKPrimitivesConfig>;

export function generateProofUtils(config: Config): string {
  return dedent(`
    // ZK Proof Utilities
    // Generated by [N]skills
    
    import { poseidon2 } from 'poseidon-lite';
    
    export type ProofType = ${config.proofTypes.map(t => `'${t}'`).join(' | ')};
    
    export interface Proof {
      type: ProofType;
      publicSignals: string[];
      proof: {
        pi_a: [string, string];
        pi_b: [[string, string], [string, string]];
        pi_c: [string, string];
      };
    }
    
    export interface MembershipProofInput {
      commitment: string;
      merkleRoot: string;
      merkleProof: string[];
      merklePathIndices: number[];
    }
    
    export interface RangeProofInput {
      value: bigint;
      min: bigint;
      max: bigint;
    }
    
    /**
     * Hash inputs using Poseidon
     */
    export function poseidonHash(inputs: bigint[]): bigint {
      return poseidon2(inputs);
    }
    
    /**
     * Generate a commitment from secret and nullifier
     */
    export function generateCommitment(secret: bigint, nullifier: bigint): bigint {
      return poseidonHash([secret, nullifier]);
    }
    
    /**
     * Generate a nullifier hash
     */
    export function generateNullifierHash(nullifier: bigint, externalNullifier: bigint): bigint {
      return poseidonHash([nullifier, externalNullifier]);
    }
    
    ${config.proofTypes.includes('membership') ? `
    /**
     * Generate a membership proof (client-side)
     * Proves that a commitment exists in a Merkle tree without revealing which one
     */
    export async function generateMembershipProof(
      input: MembershipProofInput
    ): Promise<Proof> {
      // In production, this would use snarkjs or a wasm prover
      // This is a placeholder structure
      console.log('Generating membership proof for commitment:', input.commitment);
      
      return {
        type: 'membership',
        publicSignals: [input.merkleRoot, input.commitment],
        proof: {
          pi_a: ['0x0', '0x0'],
          pi_b: [['0x0', '0x0'], ['0x0', '0x0']],
          pi_c: ['0x0', '0x0'],
        },
      };
    }
    ` : ''}
    
    ${config.proofTypes.includes('range') ? `
    /**
     * Generate a range proof (client-side)
     * Proves that a value is within a range without revealing the exact value
     */
    export async function generateRangeProof(
      input: RangeProofInput
    ): Promise<Proof> {
      if (input.value < input.min || input.value > input.max) {
        throw new Error('Value out of range');
      }
      
      return {
        type: 'range',
        publicSignals: [input.min.toString(), input.max.toString()],
        proof: {
          pi_a: ['0x0', '0x0'],
          pi_b: [['0x0', '0x0'], ['0x0', '0x0']],
          pi_c: ['0x0', '0x0'],
        },
      };
    }
    ` : ''}
    
    ${config.proofTypes.includes('semaphore') ? `
    /**
     * Generate a Semaphore signal proof
     * Anonymous signaling with rate limiting
     */
    export async function generateSemaphoreProof(
      identityCommitment: bigint,
      merkleRoot: bigint,
      signal: string,
      externalNullifier: bigint
    ): Promise<Proof> {
      const signalHash = poseidonHash([BigInt(signal)]);
      
      return {
        type: 'semaphore',
        publicSignals: [
          merkleRoot.toString(),
          signalHash.toString(),
          externalNullifier.toString(),
        ],
        proof: {
          pi_a: ['0x0', '0x0'],
          pi_b: [['0x0', '0x0'], ['0x0', '0x0']],
          pi_c: ['0x0', '0x0'],
        },
      };
    }
    ` : ''}
    
    /**
     * Verify a proof on-chain (calls verifier contract)
     */
    export function encodeProofForContract(proof: Proof): {
      a: [bigint, bigint];
      b: [[bigint, bigint], [bigint, bigint]];
      c: [bigint, bigint];
      input: bigint[];
    } {
      return {
        a: [BigInt(proof.proof.pi_a[0]), BigInt(proof.proof.pi_a[1])],
        b: [
          [BigInt(proof.proof.pi_b[0][0]), BigInt(proof.proof.pi_b[0][1])],
          [BigInt(proof.proof.pi_b[1][0]), BigInt(proof.proof.pi_b[1][1])],
        ],
        c: [BigInt(proof.proof.pi_c[0]), BigInt(proof.proof.pi_c[1])],
        input: proof.publicSignals.map(s => BigInt(s)),
      };
    }
  `);
}

export function generateZKHooks(config: Config): string {
  return dedent(`
    // ZK Proof Hooks
    // Generated by [N]skills
    
    'use client';
    
    import { useState, useCallback } from 'react';
    import {
      ${config.proofTypes.includes('membership') ? 'generateMembershipProof, type MembershipProofInput,' : ''}
      ${config.proofTypes.includes('range') ? 'generateRangeProof, type RangeProofInput,' : ''}
      ${config.proofTypes.includes('semaphore') ? 'generateSemaphoreProof,' : ''}
      encodeProofForContract,
      type Proof,
    } from '@/lib/zk/proof-utils';
    
    export interface UseZKProofsReturn {
      isGenerating: boolean;
      error: Error | null;
      lastProof: Proof | null;
      ${config.proofTypes.includes('membership') ? 'generateMembershipProof: (input: MembershipProofInput) => Promise<Proof>;' : ''}
      ${config.proofTypes.includes('range') ? 'generateRangeProof: (input: RangeProofInput) => Promise<Proof>;' : ''}
      ${config.proofTypes.includes('semaphore') ? 'generateSemaphoreProof: (identityCommitment: bigint, merkleRoot: bigint, signal: string, externalNullifier: bigint) => Promise<Proof>;' : ''}
      encodeForContract: (proof: Proof) => ReturnType<typeof encodeProofForContract>;
    }
    
    export function useZKProofs(): UseZKProofsReturn {
      const [isGenerating, setIsGenerating] = useState(false);
      const [error, setError] = useState<Error | null>(null);
      const [lastProof, setLastProof] = useState<Proof | null>(null);
      
      ${config.proofTypes.includes('membership') ? `
      const handleGenerateMembershipProof = useCallback(async (input: MembershipProofInput) => {
        setIsGenerating(true);
        setError(null);
        
        try {
          const proof = await generateMembershipProof(input);
          setLastProof(proof);
          return proof;
        } catch (err) {
          const e = err instanceof Error ? err : new Error('Proof generation failed');
          setError(e);
          throw e;
        } finally {
          setIsGenerating(false);
        }
      }, []);
      ` : ''}
      
      ${config.proofTypes.includes('range') ? `
      const handleGenerateRangeProof = useCallback(async (input: RangeProofInput) => {
        setIsGenerating(true);
        setError(null);
        
        try {
          const proof = await generateRangeProof(input);
          setLastProof(proof);
          return proof;
        } catch (err) {
          const e = err instanceof Error ? err : new Error('Proof generation failed');
          setError(e);
          throw e;
        } finally {
          setIsGenerating(false);
        }
      }, []);
      ` : ''}
      
      ${config.proofTypes.includes('semaphore') ? `
      const handleGenerateSemaphoreProof = useCallback(async (
        identityCommitment: bigint,
        merkleRoot: bigint,
        signal: string,
        externalNullifier: bigint
      ) => {
        setIsGenerating(true);
        setError(null);
        
        try {
          const proof = await generateSemaphoreProof(
            identityCommitment,
            merkleRoot,
            signal,
            externalNullifier
          );
          setLastProof(proof);
          return proof;
        } catch (err) {
          const e = err instanceof Error ? err : new Error('Proof generation failed');
          setError(e);
          throw e;
        } finally {
          setIsGenerating(false);
        }
      }, []);
      ` : ''}
      
      return {
        isGenerating,
        error,
        lastProof,
        ${config.proofTypes.includes('membership') ? 'generateMembershipProof: handleGenerateMembershipProof,' : ''}
        ${config.proofTypes.includes('range') ? 'generateRangeProof: handleGenerateRangeProof,' : ''}
        ${config.proofTypes.includes('semaphore') ? 'generateSemaphoreProof: handleGenerateSemaphoreProof,' : ''}
        encodeForContract: encodeProofForContract,
      };
    }
  `);
}

export function generateVerifierHelpers(config: Config): string {
  return dedent(`
    // SPDX-License-Identifier: MIT
    pragma solidity ^0.8.24;
    
    /**
     * @title ZKVerifier
     * @notice Groth16 proof verifier for ZK proofs
     * @dev Generated by [N]skills
     */
    contract ZKVerifier {
        // Verification key components would be set here after trusted setup
        
        struct Proof {
            uint256[2] a;
            uint256[2][2] b;
            uint256[2] c;
        }
        
        ${config.proofTypes.includes('membership') ? `
        /**
         * @notice Verify a membership proof
         * @param proof The Groth16 proof
         * @param publicSignals Public inputs [merkleRoot, commitment]
         * @return valid Whether the proof is valid
         */
        function verifyMembershipProof(
            Proof calldata proof,
            uint256[] calldata publicSignals
        ) external pure returns (bool valid) {
            require(publicSignals.length >= 2, "Invalid public signals");
            
            // In production, this would perform actual pairing checks
            // Placeholder: always returns true for development
            return true;
        }
        ` : ''}
        
        ${config.proofTypes.includes('range') ? `
        /**
         * @notice Verify a range proof
         * @param proof The Groth16 proof
         * @param publicSignals Public inputs [min, max]
         * @return valid Whether the proof is valid
         */
        function verifyRangeProof(
            Proof calldata proof,
            uint256[] calldata publicSignals
        ) external pure returns (bool valid) {
            require(publicSignals.length >= 2, "Invalid public signals");
            
            // Placeholder verification
            return true;
        }
        ` : ''}
        
        ${config.proofTypes.includes('semaphore') ? `
        /**
         * @notice Verify a Semaphore proof
         * @param proof The Groth16 proof
         * @param publicSignals Public inputs [merkleRoot, signalHash, externalNullifier]
         * @return valid Whether the proof is valid
         */
        function verifySemaphoreProof(
            Proof calldata proof,
            uint256[] calldata publicSignals
        ) external pure returns (bool valid) {
            require(publicSignals.length >= 3, "Invalid public signals");
            
            // Placeholder verification
            return true;
        }
        ` : ''}
    }
  `);
}

